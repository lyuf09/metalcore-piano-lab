<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Metalcore Piano Rhythm</title>
  <style>
    :root {
      --bg: #090b0f;
      --panel: #11141a;
      --line: rgba(226, 236, 248, 0.13);
      --line-soft: rgba(226, 236, 248, 0.07);
      --accent: #b7c4d3;
      --accent-2: #f2d9a2;
      --text: #eef3f9;
      --muted: #9ea9b6;
      --danger: #e06c75;
      --lane-1: #3c4858;
      --lane-2: #435061;
      --lane-3: #4a5768;
      --lane-4: #516070;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Avenir Next", "SF Pro Display", "Noto Sans SC", "PingFang SC", "Microsoft YaHei", sans-serif;
      background:
        radial-gradient(80vmax 60vmax at 12% -10%, rgba(246, 234, 200, 0.07), transparent 56%),
        radial-gradient(60vmax 44vmax at 84% 100%, rgba(164, 184, 210, 0.08), transparent 64%),
        var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: grid;
      place-items: center;
      padding: 20px;
      position: relative;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background:
        linear-gradient(120deg, rgba(255, 255, 255, 0.05), transparent 24%),
        linear-gradient(240deg, rgba(248, 229, 188, 0.04), transparent 30%);
      pointer-events: none;
      opacity: 0.62;
    }

    .app {
      width: min(100%, 1720px);
      display: grid;
      grid-template-columns: 560px 1fr;
      gap: 24px;
    }

    .panel {
      background:
        linear-gradient(160deg, rgba(255, 255, 255, 0.045) 0%, rgba(255, 255, 255, 0) 26%),
        linear-gradient(180deg, rgba(18, 22, 30, 0.82), rgba(12, 15, 21, 0.8));
      border: 1px solid var(--line);
      border-radius: 18px;
      padding: 16px;
      box-shadow:
        0 26px 56px rgba(0, 0, 0, 0.46),
        0 4px 16px rgba(0, 0, 0, 0.22),
        inset 0 1px 0 rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(14px);
    }

    .left {
      display: grid;
      gap: 12px;
      align-content: start;
    }

    .controls-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(3, minmax(0, 1fr));
    }

    h1 {
      margin: 0;
      font-size: 24px;
      letter-spacing: 0.75px;
      font-weight: 750;
      text-shadow: 0 1px 0 rgba(255, 255, 255, 0.08);
    }

    p {
      margin: 0;
      color: var(--muted);
      line-height: 1.5;
      font-size: 13px;
    }

    .group {
      display: grid;
      gap: 8px;
      border-top: 1px solid var(--line-soft);
      padding-top: 10px;
    }

    .row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
    }

    .muted {
      color: var(--muted);
      font-size: 12px;
    }

    input[type="file"],
    button,
    input[type="range"],
    select,
    input[type="checkbox"] {
      width: 100%;
    }

    input[type="file"] {
      font-size: 12px;
      color: var(--muted);
      border: 1px solid var(--line-soft);
      border-radius: 12px;
      padding: 8px 10px;
      background: rgba(19, 24, 32, 0.44);
    }

    input[type="file"]::file-selector-button {
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: linear-gradient(180deg, rgba(238, 246, 255, 0.24), rgba(132, 150, 170, 0.2));
      color: #f6f9fe;
      border-radius: 9px;
      padding: 7px 10px;
      margin-right: 10px;
      font-weight: 650;
      cursor: pointer;
    }

    select {
      background:
        linear-gradient(180deg, rgba(32, 39, 50, 0.55), rgba(17, 22, 29, 0.55));
      color: var(--text);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 9px 11px;
      font-size: 12px;
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.08),
        0 8px 18px rgba(0, 0, 0, 0.2);
    }

    input[type="checkbox"] {
      width: 20px;
      height: 20px;
      accent-color: var(--accent);
      justify-self: end;
    }

    button {
      border: 1px solid rgba(255, 255, 255, 0.16);
      background:
        linear-gradient(180deg, rgba(232, 240, 250, 0.28), rgba(157, 176, 198, 0.2)),
        linear-gradient(180deg, #2f3a49, #232c37);
      color: #f8fbff;
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 700;
      letter-spacing: 0.25px;
      cursor: pointer;
      box-shadow:
        0 10px 18px rgba(0, 0, 0, 0.36),
        inset 0 1px 0 rgba(255, 255, 255, 0.24);
      transition: transform 0.16s ease, box-shadow 0.2s ease, border-color 0.2s ease;
    }

    button.secondary {
      background:
        linear-gradient(180deg, rgba(220, 230, 242, 0.12), rgba(220, 230, 242, 0.06)),
        linear-gradient(180deg, #1f2732, #1a2028);
    }

    button:hover:not(:disabled) {
      transform: translateY(-1px);
      border-color: rgba(255, 255, 255, 0.26);
      box-shadow:
        0 14px 24px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.28);
    }

    button:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    #status {
      color: rgba(228, 238, 249, 0.86);
      font-size: 12px;
      min-height: 32px;
      letter-spacing: 0.2px;
    }

    input[type="range"] {
      appearance: none;
      height: 7px;
      border-radius: 999px;
      background:
        linear-gradient(90deg, rgba(243, 219, 163, 0.32), rgba(201, 218, 238, 0.32)),
        rgba(40, 48, 60, 0.75);
      border: 1px solid var(--line-soft);
    }

    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: radial-gradient(circle at 34% 30%, #ffffff, #dfe7f2 56%, #b8c6d6 100%);
      border: 1px solid rgba(255, 255, 255, 0.72);
      box-shadow: 0 0 0 5px rgba(246, 234, 200, 0.12), 0 4px 10px rgba(0, 0, 0, 0.34);
      cursor: pointer;
    }

    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: radial-gradient(circle at 34% 30%, #ffffff, #dfe7f2 56%, #b8c6d6 100%);
      border: 1px solid rgba(255, 255, 255, 0.72);
      box-shadow: 0 0 0 5px rgba(246, 234, 200, 0.12), 0 4px 10px rgba(0, 0, 0, 0.34);
      cursor: pointer;
    }

    .stats {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      font-size: 13px;
    }

    .stat {
      background: linear-gradient(180deg, rgba(20, 26, 34, 0.64), rgba(12, 15, 21, 0.64));
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 9px;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.08);
    }

    .stat strong {
      display: block;
      color: var(--text);
      font-size: 16px;
      margin-top: 2px;
    }

    .game-wrap {
      display: grid;
      gap: 10px;
      width: min(100%, 980px);
      margin: 0 auto;
    }

    canvas {
      width: 100%;
      height: 620px;
      border-radius: 18px;
      border: 1px solid var(--line);
      background:
        linear-gradient(180deg, rgba(26, 33, 43, 0.43), rgba(14, 18, 25, 0.4) 74%);
      display: block;
      box-shadow:
        0 22px 40px rgba(0, 0, 0, 0.38),
        inset 0 1px 0 rgba(255, 255, 255, 0.08);
    }

    .keys {
      display: grid;
      gap: 8px;
    }

    .key {
      text-align: center;
      padding: 8px;
      border: 1px solid var(--line);
      border-radius: 10px;
      background:
        linear-gradient(180deg, rgba(248, 252, 255, 0.08), rgba(248, 252, 255, 0.02)),
        rgba(18, 23, 31, 0.48);
      font-size: 12px;
      color: var(--muted);
      user-select: none;
      touch-action: manipulation;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    .hit {
      box-shadow:
        0 0 0 1px rgba(255, 245, 220, 0.74) inset,
        0 0 16px rgba(255, 228, 166, 0.28);
      color: var(--text);
    }

    .watermark {
      position: fixed;
      right: 24px;
      bottom: 18px;
      font-size: 12px;
      letter-spacing: 1.2px;
      color: rgba(225, 234, 245, 0.76);
      pointer-events: none;
      text-transform: uppercase;
      z-index: 2;
      text-shadow: 0 1px 8px rgba(255, 237, 196, 0.22);
    }

    .logo-bg {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      opacity: 1;
      filter: blur(0.4px);
      pointer-events: none;
      z-index: 0;
    }

    .logo-bg img {
      width: min(82vmin, 900px);
      height: min(82vmin, 900px);
      object-fit: contain;
    }

    .app,
    .watermark {
      position: relative;
      z-index: 1;
    }

    .guide {
      position: fixed;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(6, 8, 12, 0.6);
      backdrop-filter: blur(6px);
      z-index: 3;
    }

    .guide-card {
      width: min(90vw, 520px);
      background:
        linear-gradient(160deg, rgba(255, 255, 255, 0.06) 0%, rgba(255, 255, 255, 0) 26%),
        linear-gradient(180deg, rgba(20, 23, 29, 0.94), rgba(16, 18, 23, 0.92));
      border: 1px solid var(--line);
      border-radius: 16px;
      padding: 18px 18px 16px;
      box-shadow:
        0 24px 48px rgba(0, 0, 0, 0.45),
        inset 0 1px 0 rgba(255, 255, 255, 0.09);
    }

    .guide-card h2 {
      margin: 0 0 8px;
      font-size: 18px;
      letter-spacing: 0.4px;
    }

    .guide-card ul {
      margin: 0 0 14px;
      padding: 0 0 0 18px;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.6;
    }

    .guide-actions {
      display: flex;
      gap: 8px;
    }

    .mobile-toggle {
      position: fixed;
      right: 16px;
      bottom: 16px;
      z-index: 4;
      display: none;
      padding: 12px 14px;
      border-radius: 999px;
      font-weight: 700;
    }

    @media (max-width: 920px) {
      .app {
        grid-template-columns: 1fr;
      }
      canvas {
        height: 64vh;
      }
      .controls-grid {
        grid-template-columns: 1fr;
      }
      .game-wrap {
        order: 1;
      }
      .left {
        order: 2;
      }
      .mobile-toggle {
        display: inline-flex;
        align-items: center;
        gap: 6px;
      }
      .left.collapsed .controls-grid,
      .left.collapsed #status,
      .left.collapsed .stats {
        display: none;
      }
      .left.collapsed {
        padding-bottom: 10px;
      }
      button,
      select,
      input[type="range"] {
        min-height: 42px;
      }
      .key {
        padding: 14px 6px;
        font-size: 14px;
      }
    }

    @media (max-width: 1300px) {
      .controls-grid {
        grid-template-columns: repeat(3, minmax(0, 1fr));
      }
    }

    @media (max-width: 1200px) {
      .controls-grid {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }
  </style>
</head>
<body>
  <div class="logo-bg"><img src="assets/logo.png" alt="" /></div>
  <button id="mobileToggle" class="mobile-toggle">控制面板</button>
  <div id="guide" class="guide">
    <div class="guide-card">
      <h2 data-i18n="guide_title">使用须知</h2>
      <ul>
        <li data-i18n="guide_1">点击左侧选择本地音频并生成谱面。</li>
        <li data-i18n="guide_2">音符落到判定线时按键（默认 D/F/J/K）。</li>
        <li data-i18n="guide_3">可切换难度、按键数量、拍号与识别模式。</li>
        <li data-i18n="guide_4">建议先开“增强识别”，不满意再关闭。</li>
        <li data-i18n="guide_5">谱面对复杂变拍可能不稳定，属正常现象。</li>
      </ul>
      <div class="guide-actions">
        <button id="guideOk" data-i18n="guide_ok">我知道了</button>
        <button id="guideHide" class="secondary" data-i18n="guide_hide">下次不再显示</button>
      </div>
    </div>
  </div>
  <div class="watermark">
    <span>Made by Haze_zzZ</span>
  </div>
  <main class="app">
    <section class="panel left">
      <div class="row" style="align-items:flex-start;">
        <div>
          <h1 data-i18n="title">前卫核钢琴节奏</h1>
          <p data-i18n="subtitle">上传本地歌曲，自动检测节拍并生成下落音符。音符落到浅灰蓝判定线时按 D / F / J / K。</p>
        </div>
        <div style="min-width:110px;">
          <select id="langToggle" aria-label="Language">
            <option value="zh">中文</option>
            <option value="en">English</option>
          </select>
        </div>
      </div>

      <div class="controls-grid">
      <div class="group">
        <label class="muted" for="audioFile" data-i18n="label_audio">歌曲文件（mp3/wav/m4a）</label>
        <input id="audioFile" type="file" accept="audio/*" />
      </div>

      <div class="group">
        <label class="muted" for="midiFile" data-i18n="label_midi">MIDI 文件（.mid/.midi）</label>
        <input id="midiFile" type="file" accept=".mid,.midi,audio/midi" />
      </div>

      <div class="group">
        <div class="row">
          <label class="muted" for="midiMode" data-i18n="label_midi_mode">MIDI 模式</label>
          <span id="midiModeText" class="muted">自动</span>
        </div>
        <select id="midiMode">
          <option value="auto">自动（主旋律）</option>
          <option value="melody">主旋律</option>
          <option value="melody_harmony">主旋律 + 和声</option>
          <option value="drums">仅鼓组</option>
          <option value="drums_plus">鼓组 + 主旋律</option>
          <option value="all">全部</option>
        </select>
      </div>

      <div class="group">
        <button id="sampleBtn" class="secondary" data-i18n="btn_sample">示例歌曲：HaM - Haze_zzZ</button>
      </div>

      <div class="group">
        <div class="row">
          <span class="muted" data-i18n="hint_files">可从“文件”或网盘选择音频</span>
        </div>
      </div>

      <div class="group">
        <button id="recordBtn" class="secondary" data-i18n="btn_record">录音模式：开始</button>
        <button id="stopRecordBtn" class="secondary" disabled data-i18n="btn_record_stop">停止录音</button>
        <div class="row">
          <span class="muted" data-i18n="record_timer_label">剩余录音</span>
          <span id="recordTimer" class="muted">60s</span>
        </div>
      </div>

        <div class="group">
          <div class="row">
            <label class="muted" for="density" data-i18n="label_density">谱面密度</label>
            <span id="densityText" class="muted">1.00x</span>
          </div>
          <input id="density" type="range" min="0.6" max="1.8" value="1" step="0.05" />
        </div>

        <div class="group">
          <div class="row">
            <label class="muted" for="offset" data-i18n="label_offset">音符偏移</label>
            <span id="offsetText" class="muted">0 ms</span>
          </div>
          <input id="offset" type="range" min="-150" max="150" value="0" step="5" />
        </div>

        <div class="group">
          <div class="row">
            <label class="muted" for="focusMode" data-i18n="label_focus">识别模式</label>
            <span id="focusText" class="muted">自动切换</span>
          </div>
          <select id="focusMode">
            <option value="auto">自动切换（每4小节）</option>
            <option value="drum">鼓优先</option>
            <option value="guitar">吉他优先</option>
            <option value="piano">钢琴优先</option>
            <option value="vocal">人声优先</option>
            <option value="mix">混合</option>
          </select>
        </div>

      <div class="group">
        <div class="row">
          <label class="muted" for="beatTrack" data-i18n="label_beat_track">节拍追踪</label>
          <span id="beatText" class="muted">开</span>
        </div>
        <input id="beatTrack" type="checkbox" checked />
      </div>

      <div class="group">
        <div class="row">
          <label class="muted" for="enhanceMode" data-i18n="label_enhance">增强识别</label>
          <span id="enhanceText" class="muted">开</span>
        </div>
        <input id="enhanceMode" type="checkbox" checked />
      </div>

      <div class="group">
        <div class="row">
          <label class="muted" for="timeSig" data-i18n="label_timesig">拍号</label>
          <span id="timeSigText" class="muted">自动</span>
        </div>
          <select id="timeSig">
            <option value="auto">自动估计</option>
            <option value="4/4">4/4</option>
            <option value="3/4">3/4</option>
            <option value="7/8">7/8</option>
            <option value="6/8">6/8</option>
            <option value="9/8">9/8</option>
            <option value="5/4">5/4</option>
            <option value="12/8">12/8</option>
          </select>
        </div>

        <div class="group">
          <div class="row">
            <label class="muted" for="difficulty" data-i18n="label_difficulty">难度</label>
            <span id="difficultyText" class="muted">普通</span>
          </div>
          <select id="difficulty">
            <option value="easy">简单</option>
            <option value="normal" selected>普通</option>
            <option value="hard">困难</option>
            <option value="expert">地狱</option>
          </select>
        </div>

        <div class="group">
          <div class="row">
            <label class="muted" for="laneCount" data-i18n="label_lane">按键数量</label>
            <span id="laneText" class="muted">4 键</span>
          </div>
          <select id="laneCount">
            <option value="4" selected>4 键</option>
            <option value="6">6 键</option>
            <option value="8">8 键</option>
          </select>
        </div>

      <div class="group">
        <div class="row">
          <label class="muted" for="beatLock" data-i18n="label_lock">节拍锁定强度</label>
          <span id="beatLockText" class="muted">65%</span>
        </div>
        <input id="beatLock" type="range" min="0" max="1" value="0.65" step="0.05" />
      </div>

      <div class="group">
        <div class="row">
          <label class="muted" for="sfxVolume" data-i18n="label_sfx">音效音量</label>
          <span id="sfxText" class="muted">80%</span>
        </div>
        <input id="sfxVolume" type="range" min="0" max="1.4" value="0.8" step="0.05" />
      </div>
      </div>

      <div class="group">
        <button id="analyzeBtn" disabled data-i18n="btn_analyze">分析并生成谱面</button>
        <button id="regenBtn" class="secondary" disabled data-i18n="btn_regen">按当前密度重新生成</button>
        <button id="playBtn" disabled data-i18n="btn_play">开始游戏</button>
        <button id="pauseBtn" class="secondary" disabled data-i18n="btn_pause">暂停</button>
      </div>

      <div id="status" data-i18n="status_idle">等待上传歌曲…</div>

      <div class="stats">
        <div class="stat"><span data-i18n="stat_bpm">估计 BPM</span><strong id="bpmStat">-</strong></div>
        <div class="stat"><span data-i18n="stat_notes">音符数</span><strong id="noteStat">-</strong></div>
        <div class="stat"><span data-i18n="stat_key">调性</span><strong id="keyStat">-</strong></div>
        <div class="stat"><span data-i18n="stat_score">分数</span><strong id="scoreStat">0</strong></div>
        <div class="stat"><span data-i18n="stat_combo">连击</span><strong id="comboStat">0</strong></div>
        <div class="stat"><span data-i18n="stat_hold">Hold</span><strong id="holdStat">0</strong></div>
        <div class="stat"><span data-i18n="stat_chord">Chord</span><strong id="chordStat">0</strong></div>
      </div>
    </section>

    <section class="game-wrap">
      <canvas id="game" width="620" height="620"></canvas>
      <div class="keys">
        <div id="key0" class="key">D</div>
        <div id="key1" class="key">F</div>
        <div id="key2" class="key">J</div>
        <div id="key3" class="key">K</div>
      </div>
    </section>
  </main>

  <script>
    const ui = {
      file: document.getElementById("audioFile"),
      midi: document.getElementById("midiFile"),
      midiMode: document.getElementById("midiMode"),
      midiModeText: document.getElementById("midiModeText"),
      analyze: document.getElementById("analyzeBtn"),
      regen: document.getElementById("regenBtn"),
      play: document.getElementById("playBtn"),
      pause: document.getElementById("pauseBtn"),
      sample: document.getElementById("sampleBtn"),
      record: document.getElementById("recordBtn"),
      stopRecord: document.getElementById("stopRecordBtn"),
      recordTimer: document.getElementById("recordTimer"),
      density: document.getElementById("density"),
      densityText: document.getElementById("densityText"),
      offset: document.getElementById("offset"),
      offsetText: document.getElementById("offsetText"),
      focusMode: document.getElementById("focusMode"),
      focusText: document.getElementById("focusText"),
      beatTrack: document.getElementById("beatTrack"),
      beatText: document.getElementById("beatText"),
      enhanceMode: document.getElementById("enhanceMode"),
      enhanceText: document.getElementById("enhanceText"),
      timeSig: document.getElementById("timeSig"),
      timeSigText: document.getElementById("timeSigText"),
      difficulty: document.getElementById("difficulty"),
      difficultyText: document.getElementById("difficultyText"),
      laneCount: document.getElementById("laneCount"),
      laneText: document.getElementById("laneText"),
      keyStat: document.getElementById("keyStat"),
      beatLock: document.getElementById("beatLock"),
      beatLockText: document.getElementById("beatLockText"),
      sfxVolume: document.getElementById("sfxVolume"),
      sfxText: document.getElementById("sfxText"),
      status: document.getElementById("status"),
      bpm: document.getElementById("bpmStat"),
      notes: document.getElementById("noteStat"),
      score: document.getElementById("scoreStat"),
      combo: document.getElementById("comboStat"),
      hold: document.getElementById("holdStat"),
      chord: document.getElementById("chordStat"),
      canvas: document.getElementById("game"),
      keyEls: []
    };

    const keySets = {
      4: ["d", "f", "j", "k"],
      6: ["a", "s", "d", "j", "k", "l"],
      8: ["a", "s", "d", "f", "j", "k", "l", ";"]
    };
    const tonePalette = [
      { hue: 195, sat: 18, light: 76 },
      { hue: 205, sat: 22, light: 70 },
      { hue: 215, sat: 26, light: 64 },
      { hue: 228, sat: 18, light: 58 },
      { hue: 238, sat: 14, light: 74 }
    ];
    let keyMap = {};
    let laneCount = 4;
    let hitWindow = 0.13;
    let perfectWindow = 0.055;
    let scrollTime = 2.1;
    let offsetSec = 0;
    let focusMode = "auto";
    let beatTrack = true;
    let beatOffset = 0;
    let beatLock = 0.65;
    let timeSig = "auto";
    let barBeats = 4;
    let difficulty = "normal";
    let enhanceMode = true;
    let laneFlash = [];
    const FLASH_DURATION = 0.2;
    let sfxVolume = 0.8;
    let keyLabel = "-";
    let keyBaseFreq = 1760;
    const particles = [];
    const MAX_PARTICLES = 320;
    const HEAVY_PARTICLE_THRESHOLD = 180;
    let activeHolds = [];
    const pressedKeys = new Set();
    let midiOnsets = null;
    let midiPlaybackOnsets = null;
    let midiBpm = null;
    let midiTimeSig = null;
    let midiDuration = 0;
    let currentSource = "audio";
    let midiMode = "auto";
    let midiSynthGain = null;
    let midiSynthFilter = null;
    let midiSynthComp = null;
    let midiNoiseBuffer = null;
    let holdReverbBuffer = null;
    let midiSynthNodes = [];

    let ctx;
    let audioBuffer = null;
    let sourceNode = null;
    let fileName = "";
    let chart = [];
    let baseOnsets = [];
    let onsetsByMode = null;
    let estimatedBpm = 120;
    let startTime = 0;
    let rafId = 0;
    let running = false;
    let score = 0;
    let combo = 0;
    let nextMissIndex = 0;
    let paused = false;
    let pauseOffset = 0;
    let recorder = null;
    let recordChunks = [];
    let recordTimeout = null;
    let recordInterval = null;
    let lastFrameTs = 0;
    let renderStartIndex = 0;
    let lastRenderTime = 0;

    const gameState = {
      width: ui.canvas.width,
      height: ui.canvas.height,
      judgeY: ui.canvas.height - 90
    };

    const g = ui.canvas.getContext("2d");

    const i18n = {
      zh: {
        guide_title: "使用须知",
        guide_1: "点击左侧选择本地音频并生成谱面。",
        guide_2: "音符落到判定线时按键（默认 D/F/J/K）。",
        guide_3: "可切换难度、按键数量、拍号与识别模式。",
        guide_4: "建议先开“增强识别”，不满意再关闭。",
        guide_5: "谱面对复杂变拍可能不稳定，属正常现象。",
        guide_ok: "我知道了",
        guide_hide: "下次不再显示",
        title: "前卫核钢琴节奏",
        subtitle: "上传本地歌曲，自动检测节拍并生成下落音符。音符落到浅灰蓝判定线时按 D / F / J / K。",
        label_audio: "歌曲文件（mp3/wav/m4a）",
        label_midi: "MIDI 文件（.mid/.midi）",
        label_midi_mode: "MIDI 模式",
        label_density: "谱面密度",
        label_offset: "音符偏移",
        label_focus: "识别模式",
        label_beat_track: "节拍追踪",
        label_enhance: "增强识别",
        label_timesig: "拍号",
        label_difficulty: "难度",
        label_lane: "按键数量",
        label_lock: "节拍锁定强度",
        label_sfx: "音效音量",
        record_timer_label: "剩余录音",
        hint_files: "可从“文件”或网盘选择音频",
        btn_analyze: "分析并生成谱面",
        btn_regen: "按当前密度重新生成",
        btn_play: "开始游戏",
        btn_pause: "暂停",
        btn_resume: "继续",
        btn_record: "录音模式：开始",
        btn_record_stop: "停止录音",
        status_recording: "正在录音…",
        status_record_done: "录音完成，点击“分析并生成谱面”。",
        btn_sample: "示例歌曲：HaM - Haze_zzZ",
        mobile_open: "控制面板",
        mobile_close: "关闭面板",
        status_idle: "等待上传歌曲…",
        status_analyzing: "正在提取打击点…",
        status_loaded: (name) => `已加载《${name}》，点击“分析并生成谱面”。`,
        status_midi_loaded: (name) => `已加载 MIDI《${name}》，点击“分析并生成谱面”。`,
        midi_auto: "自动（主旋律）",
        midi_melody: "主旋律",
        midi_melody_harmony: "主旋律 + 和声",
        midi_drums: "仅鼓组",
        midi_drums_plus: "鼓组 + 主旋律",
        midi_all: "全部",
        status_ready: (name) => `已为《${name}》生成谱面，可直接开始游戏。`,
        status_none: "没有检测到足够的打击点，请提高谱面密度或换首节奏更明显的歌。",
        status_regen: (d) => `已按 ${d}x 密度重建谱面。`,
        status_playing: "游戏进行中…",
        status_end: (score) => `歌曲结束，最终分数 ${score}。`,
        stat_bpm: "估计 BPM",
        stat_notes: "音符数",
        stat_key: "调性",
        stat_score: "分数",
        stat_combo: "连击",
        stat_hold: "Hold",
        stat_chord: "Chord",
        focus_auto: "自动切换（每4小节）",
        focus_drum: "鼓优先",
        focus_guitar: "吉他优先",
        focus_piano: "钢琴优先",
        focus_vocal: "人声优先",
        focus_mix: "混合",
        beat_on: "开",
        beat_off: "关",
        enhance_on: "开",
        enhance_off: "关",
        time_auto: "自动估计",
        difficulty_easy: "简单",
        difficulty_normal: "普通",
        difficulty_hard: "困难",
        difficulty_expert: "地狱",
        lane_keys: (n) => `${n} 键`,
        custom: "自定义"
      },
      en: {
        guide_title: "Quick Start",
        guide_1: "Choose a local audio file on the left and generate a chart.",
        guide_2: "Press when notes hit the judgment line (default D/F/J/K).",
        guide_3: "Switch difficulty, key count, time signature, and mode.",
        guide_4: "Try Enhanced mode first; turn it off if needed.",
        guide_5: "Complex meter changes may reduce accuracy.",
        guide_ok: "Got it",
        guide_hide: "Don't show again",
        title: "Metalcore Piano Rhythm",
        subtitle: "Upload audio to auto‑generate falling notes. Hit at the judgment line with D / F / J / K.",
        label_audio: "Audio file (mp3/wav/m4a)",
        label_midi: "MIDI file (.mid/.midi)",
        label_midi_mode: "MIDI Mode",
        label_density: "Chart Density",
        label_offset: "Note Offset",
        label_focus: "Detection Mode",
        label_beat_track: "Beat Tracking",
        label_enhance: "Enhanced Mode",
        label_timesig: "Time Signature",
        label_difficulty: "Difficulty",
        label_lane: "Key Count",
        label_lock: "Beat Lock",
        label_sfx: "SFX Volume",
        record_timer_label: "Recording left",
        hint_files: "Choose audio from Files or cloud drives",
        btn_analyze: "Analyze & Generate",
        btn_regen: "Regenerate",
        btn_play: "Start",
        btn_pause: "Pause",
        btn_resume: "Resume",
        btn_record: "Record: Start",
        btn_record_stop: "Stop Recording",
        status_recording: "Recording…",
        status_record_done: "Recording ready. Click Analyze.",
        btn_sample: "Sample: HaM - Haze_zzZ",
        mobile_open: "Controls",
        mobile_close: "Hide Controls",
        status_idle: "Waiting for audio…",
        status_analyzing: "Analyzing onsets…",
        status_loaded: (name) => `Loaded “${name}”. Click Analyze.`,
        status_midi_loaded: (name) => `MIDI loaded: “${name}”. Click Analyze.`,
        midi_auto: "Auto (Melody)",
        midi_melody: "Melody",
        midi_melody_harmony: "Melody + Harmony",
        midi_drums: "Drums only",
        midi_drums_plus: "Drums + Melody",
        midi_all: "All",
        status_ready: (name) => `Chart ready for “${name}”.`,
        status_none: "Not enough onsets detected. Increase density or try another track.",
        status_regen: (d) => `Regenerated at ${d}x density.`,
        status_playing: "Playing…",
        status_end: (score) => `Song ended. Final score ${score}.`,
        stat_bpm: "Estimated BPM",
        stat_notes: "Notes",
        stat_key: "Key",
        stat_score: "Score",
        stat_combo: "Combo",
        stat_hold: "Hold",
        stat_chord: "Chord",
        focus_auto: "Auto (per 4 bars)",
        focus_drum: "Drum‑focused",
        focus_guitar: "Guitar‑focused",
        focus_piano: "Piano‑focused",
        focus_vocal: "Vocal‑focused",
        focus_mix: "Mixed",
        beat_on: "On",
        beat_off: "Off",
        enhance_on: "On",
        enhance_off: "Off",
        time_auto: "Auto",
        difficulty_easy: "Easy",
        difficulty_normal: "Normal",
        difficulty_hard: "Hard",
        difficulty_expert: "Expert",
        lane_keys: (n) => `${n} Keys`,
        custom: "Custom"
      }
    };

    let lang = "zh";
    const t = (key, ...args) => {
      const val = i18n[lang][key];
      return typeof val === "function" ? val(...args) : val;
    };

    function applyI18n() {
      document.querySelectorAll("[data-i18n]").forEach((el) => {
        const key = el.getAttribute("data-i18n");
        if (i18n[lang][key]) el.textContent = i18n[lang][key];
      });
      const focusLabels = {
        auto: t("focus_auto"),
        drum: t("focus_drum"),
        guitar: t("focus_guitar"),
        piano: t("focus_piano"),
        vocal: t("focus_vocal"),
        mix: t("focus_mix")
      };
      Array.from(ui.focusMode.options).forEach((opt) => {
        opt.textContent = focusLabels[opt.value] || opt.value;
      });
      const timeAuto = t("time_auto");
      Array.from(ui.timeSig.options).forEach((opt) => {
        if (opt.value === "auto") opt.textContent = timeAuto;
      });
      const diffLabels = {
        easy: t("difficulty_easy"),
        normal: t("difficulty_normal"),
        hard: t("difficulty_hard"),
        expert: t("difficulty_expert")
      };
      Array.from(ui.difficulty.options).forEach((opt) => {
        opt.textContent = diffLabels[opt.value] || opt.value;
      });
      Array.from(ui.laneCount.options).forEach((opt) => {
        opt.textContent = t("lane_keys", opt.value);
      });
      const midiLabels = {
        auto: t("midi_auto"),
        melody: t("midi_melody"),
        melody_harmony: t("midi_melody_harmony"),
        drums: t("midi_drums"),
        drums_plus: t("midi_drums_plus"),
        all: t("midi_all")
      };
      Array.from(ui.midiMode.options).forEach((opt) => {
        opt.textContent = midiLabels[opt.value] || opt.value;
      });
      ui.midiModeText.textContent = midiLabels[midiMode] || t("midi_auto");
      ui.focusText.textContent = focusLabels[focusMode] || t("focus_mix");
      ui.beatText.textContent = beatTrack ? t("beat_on") : t("beat_off");
      ui.enhanceText.textContent = enhanceMode ? t("enhance_on") : t("enhance_off");
      ui.timeSigText.textContent = timeSig === "auto" ? t("time_auto") : timeSig;
      ui.difficultyText.textContent = diffLabels[difficulty] || t("difficulty_normal");
      ui.laneText.textContent = t("lane_keys", laneCount);
      ui.pause.textContent = paused ? t("btn_resume") : t("btn_pause");
    }

    function buildKeyMap() {
      keyMap = {};
      const keys = keySets[laneCount] || keySets[4];
      keys.forEach((k, i) => {
        keyMap[k] = i;
      });
      laneFlash = new Array(laneCount).fill(-999);
      activeHolds = new Array(laneCount).fill(null);
      ui.keyEls = [];
      const keysWrap = document.querySelector(".keys");
      keysWrap.style.gridTemplateColumns = `repeat(${laneCount}, 1fr)`;
      keysWrap.innerHTML = "";
      for (let i = 0; i < laneCount; i += 1) {
        const el = document.createElement("div");
        el.className = "key";
        el.textContent = (keys[i] || "?").toUpperCase();
        el.dataset.lane = String(i);
        el.addEventListener("pointerdown", (e) => {
          e.preventDefault();
          const lane = Number(el.dataset.lane);
          if (pressedKeys.has(`p${lane}`)) return;
          pressedKeys.add(`p${lane}`);
          el.classList.add("hit");
          setTimeout(() => el.classList.remove("hit"), 80);
          hitLane(lane);
        });
        el.addEventListener("pointerup", () => {
          const lane = Number(el.dataset.lane);
          pressedKeys.delete(`p${lane}`);
          releaseLane(lane);
        });
        el.addEventListener("pointerleave", () => {
          const lane = Number(el.dataset.lane);
          pressedKeys.delete(`p${lane}`);
          releaseLane(lane);
        });
        keysWrap.appendChild(el);
        ui.keyEls.push(el);
      }
    }

    function updateDifficulty() {
      const map = {
        easy: { density: 0.8, hit: 0.15, perfect: 0.065, label: t("difficulty_easy") },
        normal: { density: 1.0, hit: 0.13, perfect: 0.055, label: t("difficulty_normal") },
        hard: { density: 1.2, hit: 0.11, perfect: 0.05, label: t("difficulty_hard") },
        expert: { density: 1.45, hit: 0.095, perfect: 0.045, label: t("difficulty_expert") }
      };
      const preset = map[difficulty] || map.normal;
      ui.density.value = String(preset.density);
      ui.densityText.textContent = `${preset.density.toFixed(2)}x`;
      hitWindow = preset.hit;
      perfectWindow = preset.perfect;
      ui.difficultyText.textContent = preset.label;
    }

    function toneColor() {
      const base = tonePalette[Math.floor(Math.random() * tonePalette.length)];
      const hue = base.hue + (Math.random() * 10 - 5);
      const sat = Math.min(32, Math.max(10, base.sat + (Math.random() * 10 - 5)));
      const light = Math.min(88, Math.max(52, base.light + (Math.random() * 12 - 6)));
      return `hsl(${hue.toFixed(1)}, ${sat.toFixed(1)}%, ${light.toFixed(1)}%)`;
    }

    function laneColor(index) {
      return tonePalette[index % tonePalette.length] ?
        `hsl(${tonePalette[index % tonePalette.length].hue}, ${tonePalette[index % tonePalette.length].sat}%, ${tonePalette[index % tonePalette.length].light}%)`
        : "#9aa7b6";
    }

    function setStatus(text, error = false) {
      ui.status.textContent = text;
      ui.status.style.color = error ? "var(--danger)" : "var(--muted)";
    }

    function ensureAudioContext() {
      if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
      return ctx;
    }

    function createSilentBuffer(duration) {
      const audioCtx = ensureAudioContext();
      const length = Math.max(1, Math.floor(duration * audioCtx.sampleRate));
      const buffer = audioCtx.createBuffer(1, length, audioCtx.sampleRate);
      return buffer;
    }

    function stopMidiSynth() {
      if (midiSynthNodes.length) {
        midiSynthNodes.forEach((n) => {
          try { n.stop(0); } catch {}
          try { n.disconnect(); } catch {}
        });
      }
      midiSynthNodes = [];
    }

    function getMidiNoiseBuffer(audioCtx) {
      if (midiNoiseBuffer && midiNoiseBuffer.sampleRate === audioCtx.sampleRate) return midiNoiseBuffer;
      const dur = 0.14;
      const length = Math.floor(audioCtx.sampleRate * dur);
      const buffer = audioCtx.createBuffer(1, length, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < length; i += 1) {
        data[i] = (Math.random() * 2 - 1) * (1 - i / length);
      }
      midiNoiseBuffer = buffer;
      return buffer;
    }

    function scheduleMidiSynth(onsets, bpm) {
      if (!onsets || !onsets.length) return;
      const audioCtx = ensureAudioContext();
      if (audioCtx.state === "suspended") {
        audioCtx.resume().catch(() => {});
      }
      if (!midiSynthGain) {
        midiSynthGain = audioCtx.createGain();
        midiSynthGain.gain.value = 0.38;
        midiSynthFilter = audioCtx.createBiquadFilter();
        midiSynthFilter.type = "lowpass";
        midiSynthFilter.frequency.value = 12000;
        midiSynthFilter.Q.value = 0.3;
        midiSynthComp = audioCtx.createDynamicsCompressor();
        midiSynthComp.threshold.value = -18;
        midiSynthComp.knee.value = 24;
        midiSynthComp.ratio.value = 3.2;
        midiSynthComp.attack.value = 0.003;
        midiSynthComp.release.value = 0.18;
        midiSynthGain.connect(midiSynthFilter);
        midiSynthFilter.connect(midiSynthComp);
        midiSynthComp.connect(audioCtx.destination);
      }
      stopMidiSynth();
      const now = audioCtx.currentTime;
      const offset = now - startTime;
      const sorted = onsets.slice().sort((a, b) => a.t - b.t);
      const nextByCh = new Map();
      const gaps = new Array(sorted.length).fill(0.12);
      for (let i = sorted.length - 1; i >= 0; i -= 1) {
        const ch = sorted[i].ch ?? 0;
        const next = nextByCh.get(ch);
        if (next) gaps[i] = Math.max(0.02, next.t - sorted[i].t);
        nextByCh.set(ch, sorted[i]);
      }
      const canPan = typeof audioCtx.createStereoPanner === "function";
      for (let i = 0; i < sorted.length; i += 1) {
        const o = sorted[i];
        const freq = 440 * Math.pow(2, (o.note - 69) / 12);
        const startAt = Math.max(audioCtx.currentTime + 0.01, now + o.t - offset);
        const vel = Math.max(0.25, Math.min(1, o.v ?? 0.6));
        const gap = gaps[i];
        const dur = o.ch === 9
          ? Math.min(0.1, gap * 0.55)
          : (o.note < 48
            ? Math.max(0.07, Math.min(0.24, gap * 0.9))
            : Math.max(0.035, Math.min(0.16, gap * 0.72)));
        const baseAmp = 0.035 + vel * 0.09;
        const outGain = audioCtx.createGain();
        outGain.gain.setValueAtTime(0.0001, startAt);
        outGain.gain.exponentialRampToValueAtTime(baseAmp, startAt + 0.01);
        outGain.gain.exponentialRampToValueAtTime(0.0001, startAt + dur);

        if (canPan) {
          const ch = o.ch ?? 0;
          const pan = audioCtx.createStereoPanner();
          const panVal = ((ch % 8) / 7) * 0.5 - 0.25;
          pan.pan.setValueAtTime(panVal, startAt);
          outGain.connect(pan);
          pan.connect(midiSynthGain);
        } else {
          outGain.connect(midiSynthGain);
        }

        if (o.ch === 9) {
          const noise = audioCtx.createBufferSource();
          noise.buffer = getMidiNoiseBuffer(audioCtx);
          const hp = audioCtx.createBiquadFilter();
          hp.type = "highpass";
          hp.frequency.value = 1200;
          noise.connect(hp);
          hp.connect(outGain);
          noise.start(startAt);
          noise.stop(startAt + 0.12);
          midiSynthNodes.push(noise);
          continue;
        }

        const osc1 = audioCtx.createOscillator();
        const osc2 = audioCtx.createOscillator();
        osc1.type = o.note > 76 ? "sawtooth" : "triangle";
        osc2.type = "sine";
        osc1.frequency.setValueAtTime(freq, startAt);
        osc2.frequency.setValueAtTime(freq * 2, startAt);
        osc2.detune.setValueAtTime(Math.random() * 8 - 4, startAt);
        osc1.connect(outGain);
        osc2.connect(outGain);
        osc1.start(startAt);
        osc2.start(startAt);
        osc1.stop(startAt + dur);
        osc2.stop(startAt + dur);
        midiSynthNodes.push(osc1, osc2);

        if (o.note < 50) {
          const sub = audioCtx.createOscillator();
          const subGain = audioCtx.createGain();
          sub.type = "sine";
          sub.frequency.setValueAtTime(freq / 2, startAt);
          subGain.gain.setValueAtTime(0.0001, startAt);
          subGain.gain.exponentialRampToValueAtTime(baseAmp * 0.45, startAt + 0.01);
          subGain.gain.exponentialRampToValueAtTime(0.0001, startAt + dur);
          sub.connect(subGain);
          subGain.connect(outGain);
          sub.start(startAt);
          sub.stop(startAt + dur);
          midiSynthNodes.push(sub);
        }
      }
    }

    function computeScrollTimeFromBpm(bpm) {
      const safeBpm = Math.max(70, Math.min(220, bpm || 120));
      // Faster songs should visually fall faster.
      return Math.max(1.28, Math.min(2.35, 230 / safeBpm));
    }

    function buildReverbImpulse(ctx, seconds = 1.1, decay = 2.6) {
      const rate = ctx.sampleRate;
      const length = Math.floor(rate * seconds);
      const impulse = ctx.createBuffer(2, length, rate);
      for (let c = 0; c < 2; c += 1) {
        const data = impulse.getChannelData(c);
        for (let i = 0; i < length; i += 1) {
          data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
        }
      }
      return impulse;
    }

    function fftInPlace(re, im) {
      const n = re.length;
      for (let i = 1, j = 0; i < n; i += 1) {
        let bit = n >> 1;
        for (; j & bit; bit >>= 1) j ^= bit;
        j ^= bit;
        if (i < j) {
          const tr = re[i];
          re[i] = re[j];
          re[j] = tr;
          const ti = im[i];
          im[i] = im[j];
          im[j] = ti;
        }
      }
      for (let len = 2; len <= n; len <<= 1) {
        const ang = -2 * Math.PI / len;
        const wlenCos = Math.cos(ang);
        const wlenSin = Math.sin(ang);
        for (let i = 0; i < n; i += len) {
          let wCos = 1;
          let wSin = 0;
          for (let j = 0; j < len / 2; j += 1) {
            const uRe = re[i + j];
            const uIm = im[i + j];
            const vRe = re[i + j + len / 2] * wCos - im[i + j + len / 2] * wSin;
            const vIm = re[i + j + len / 2] * wSin + im[i + j + len / 2] * wCos;
            re[i + j] = uRe + vRe;
            im[i + j] = uIm + vIm;
            re[i + j + len / 2] = uRe - vRe;
            im[i + j + len / 2] = uIm - vIm;
            const nextCos = wCos * wlenCos - wSin * wlenSin;
            const nextSin = wCos * wlenSin + wSin * wlenCos;
            wCos = nextCos;
            wSin = nextSin;
          }
        }
      }
    }

    function estimateKeyFromBuffer(buffer) {
      const mono = toMono(buffer);
      const sr = buffer.sampleRate;
      const size = 2048;
      const hop = 4096;
      const maxFrames = 120;
      const chroma = new Float32Array(12);
      const re = new Float32Array(size);
      const im = new Float32Array(size);
      const hann = new Float32Array(size);
      for (let i = 0; i < size; i += 1) {
        hann[i] = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (size - 1)));
      }

      const step = Math.max(hop, Math.floor(mono.length / maxFrames));
      for (let start = 0; start + size < mono.length; start += step) {
        for (let i = 0; i < size; i += 1) {
          re[i] = mono[start + i] * hann[i];
          im[i] = 0;
        }
        fftInPlace(re, im);
        const freqRes = sr / size;
        for (let bin = 2; bin < size / 2; bin += 1) {
          const freq = bin * freqRes;
          if (freq < 60 || freq > 4000) continue;
          const mag = re[bin] * re[bin] + im[bin] * im[bin];
          const pitch = 12 * Math.log2(freq / 440) + 9;
          const pc = ((Math.round(pitch) % 12) + 12) % 12;
          chroma[pc] += mag;
        }
      }

      const total = chroma.reduce((a, b) => a + b, 0);
      if (total <= 0) return { label: "-", root: 9, mode: "major" };
      for (let i = 0; i < 12; i += 1) chroma[i] /= total;

      const majorProfile = [0.748, 0.06, 0.488, 0.082, 0.67, 0.46, 0.096, 0.715, 0.104, 0.366, 0.057, 0.4];
      const minorProfile = [0.712, 0.084, 0.474, 0.618, 0.049, 0.46, 0.105, 0.747, 0.404, 0.067, 0.133, 0.33];
      const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
      let best = { score: -1, root: 0, mode: "major" };

      for (let root = 0; root < 12; root += 1) {
        let scoreMaj = 0;
        let scoreMin = 0;
        for (let i = 0; i < 12; i += 1) {
          const idx = (i + root) % 12;
          scoreMaj += chroma[idx] * majorProfile[i];
          scoreMin += chroma[idx] * minorProfile[i];
        }
        if (scoreMaj > best.score) best = { score: scoreMaj, root, mode: "major" };
        if (scoreMin > best.score) best = { score: scoreMin, root, mode: "minor" };
      }

      const label = `${noteNames[best.root]} ${best.mode === "major" ? "major" : "minor"}`;
      return { label, root: best.root, mode: best.mode };
    }

    function playHitSound(kind) {
      const audioCtx = ensureAudioContext();
      if (audioCtx.state === "suspended") {
        audioCtx.resume().catch(() => {});
      }
      const now = audioCtx.currentTime;
      const baseRoot = keyBaseFreq || 1760;
      const base = kind === "perfect" ? baseRoot * 1.18 : baseRoot;
      const partials = [1, 2.1, 2.9, 4.1, 5.3];
      const gains = [0.16, 0.1, 0.07, 0.05, 0.035];
      const output = audioCtx.createGain();
      const dry = audioCtx.createGain();
      const wet = audioCtx.createGain();
      const convolver = audioCtx.createConvolver();
      if (!convolver.buffer) convolver.buffer = buildReverbImpulse(audioCtx, 1.3, 3.2);
      output.gain.setValueAtTime(0.0001, now);
      output.gain.exponentialRampToValueAtTime(0.6 * sfxVolume, now + 0.01);
      output.gain.exponentialRampToValueAtTime(0.0001, now + 0.8);
      dry.gain.value = 0.35;
      wet.gain.value = 1.1;
      output.connect(dry);
      output.connect(convolver);
      convolver.connect(wet);
      dry.connect(audioCtx.destination);
      wet.connect(audioCtx.destination);

      for (let i = 0; i < partials.length; i += 1) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = "sine";
        osc.frequency.setValueAtTime(base * partials[i], now);
        osc.frequency.exponentialRampToValueAtTime(base * partials[i] * 0.985, now + 0.12);
        gain.gain.setValueAtTime(gains[i], now);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + 0.55 + i * 0.06);
        osc.connect(gain);
        gain.connect(output);
        osc.start(now);
        osc.stop(now + 0.6 + i * 0.06);
      }

      // Brushed sparkle: longer, smoother high-band noise tail.
      const noiseDur = 0.65;
      const noiseBuffer = audioCtx.createBuffer(1, Math.floor(audioCtx.sampleRate * noiseDur), audioCtx.sampleRate);
      const data = noiseBuffer.getChannelData(0);
      for (let i = 0; i < data.length; i += 1) {
        data[i] = (Math.random() * 2 - 1) * (1 - i / data.length);
      }
      const noise = audioCtx.createBufferSource();
      noise.buffer = noiseBuffer;
      const bp = audioCtx.createBiquadFilter();
      bp.type = "bandpass";
      bp.frequency.value = 8200;
      bp.Q.value = 0.4;
      const lp = audioCtx.createBiquadFilter();
      lp.type = "lowpass";
      lp.frequency.value = 11000;
      const noiseGain = audioCtx.createGain();
      noiseGain.gain.setValueAtTime(0.0001, now);
      noiseGain.gain.exponentialRampToValueAtTime(0.32 * sfxVolume, now + 0.02);
      noiseGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.7);
      noise.connect(bp);
      bp.connect(lp);
      lp.connect(noiseGain);
      noiseGain.connect(output);
      noise.start(now);
      noise.stop(now + noiseDur);
    }

    function startHoldSustain(lane, note) {
      const audioCtx = ensureAudioContext();
      if (audioCtx.state === "suspended") {
        audioCtx.resume().catch(() => {});
      }
      const now = audioCtx.currentTime;
      // Keep hold timbre close to hit SFX: bright, high, bell-like.
      const laneOffsets = [0, 2, 5, 7, 9, 12, 14, 17];
      const laneSemi = laneOffsets[lane % laneOffsets.length] || 0;
      const base = (keyBaseFreq || 1760) * Math.pow(2, laneSemi / 12);
      const output = audioCtx.createGain();
      output.gain.setValueAtTime(0.0001, now);
      output.gain.exponentialRampToValueAtTime(Math.max(0.002, 0.14 * sfxVolume), now + 0.05);

      const dry = audioCtx.createGain();
      const wet = audioCtx.createGain();
      dry.gain.value = 0.38;
      wet.gain.value = 0.95;
      const convolver = audioCtx.createConvolver();
      if (!holdReverbBuffer) holdReverbBuffer = buildReverbImpulse(audioCtx, 1.05, 3.0);
      convolver.buffer = holdReverbBuffer;

      output.connect(dry);
      output.connect(convolver);
      convolver.connect(wet);
      dry.connect(audioCtx.destination);
      wet.connect(audioCtx.destination);

      const partials = [1, 2.1, 2.9, 4.1, 5.3];
      const levels = [0.07, 0.05, 0.032, 0.022, 0.016];
      const oscs = [];
      const gains = [];
      for (let i = 0; i < partials.length; i += 1) {
        const osc = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        osc.type = "sine";
        osc.frequency.setValueAtTime(base * partials[i], now);
        osc.detune.setValueAtTime((Math.random() * 4 - 2), now);
        g.gain.setValueAtTime(levels[i], now);
        osc.connect(g);
        g.connect(output);
        osc.start(now);
        oscs.push(osc);
        gains.push(g);
      }

      const lfo = audioCtx.createOscillator();
      const lfoGain = audioCtx.createGain();
      lfo.type = "sine";
      lfo.frequency.setValueAtTime(6.2, now);
      lfoGain.gain.setValueAtTime(0.018 * Math.max(0.6, sfxVolume), now);
      lfo.connect(lfoGain);
      lfoGain.connect(output.gain);
      lfo.start(now);
      return { output, dry, wet, convolver, oscs, gains, lfo, lfoGain };
    }

    function stopHoldSustain(holdEntry) {
      if (!holdEntry || !holdEntry.sustain) return;
      const audioCtx = ensureAudioContext();
      const now = audioCtx.currentTime;
      const s = holdEntry.sustain;
      try {
        s.output.gain.cancelScheduledValues(now);
        s.output.gain.setValueAtTime(Math.max(0.0001, s.output.gain.value || 0.02), now);
        s.output.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);
        for (const osc of s.oscs || []) osc.stop(now + 0.14);
        if (s.lfo) s.lfo.stop(now + 0.14);
      } catch {}
      holdEntry.sustain = null;
    }

    function resetScore() {
      score = 0;
      combo = 0;
      nextMissIndex = 0;
      activeHolds = new Array(laneCount).fill(null);
      ui.score.textContent = "0";
      ui.combo.textContent = "0";
    }

    function stopGame() {
      running = false;
      cancelAnimationFrame(rafId);
      paused = false;
      stopMidiSynth();
      for (const ah of activeHolds) {
        if (ah) stopHoldSustain(ah);
      }
      activeHolds = new Array(laneCount).fill(null);
      if (sourceNode) {
        sourceNode.onended = null;
        sourceNode.stop(0);
        sourceNode.disconnect();
        sourceNode = null;
      }
    }

    function toMono(buffer) {
      const channels = buffer.numberOfChannels;
      const length = buffer.length;
      const mono = new Float32Array(length);
      for (let c = 0; c < channels; c += 1) {
        const data = buffer.getChannelData(c);
        for (let i = 0; i < length; i += 1) mono[i] += data[i] / channels;
      }
      return mono;
    }

    function movingAverage(values, radius) {
      const out = new Float32Array(values.length);
      let sum = 0;
      for (let i = 0; i < values.length; i += 1) {
        sum += values[i];
        if (i > radius) sum -= values[i - radius - 1];
        const size = Math.min(i + 1, radius + 1);
        out[i] = sum / size;
      }
      return out;
    }

    function preEmphasis(input, coeff = 0.97) {
      const out = new Float32Array(input.length);
      if (!input.length) return out;
      out[0] = input[0];
      for (let i = 1; i < input.length; i += 1) {
        out[i] = input[i] - coeff * input[i - 1];
      }
      return out;
    }

    async function filterDrumBand(buffer) {
      const offline = new OfflineAudioContext(1, buffer.length, buffer.sampleRate);
      const source = offline.createBufferSource();
      source.buffer = buffer;
      const hp = offline.createBiquadFilter();
      hp.type = "highpass";
      hp.frequency.value = 60;
      hp.Q.value = 0.707;
      const lp = offline.createBiquadFilter();
      lp.type = "lowpass";
      lp.frequency.value = 2400;
      lp.Q.value = 0.707;
      source.connect(hp);
      hp.connect(lp);
      lp.connect(offline.destination);
      source.start(0);
      return offline.startRendering();
    }

    async function filterGuitarBand(buffer) {
      const offline = new OfflineAudioContext(1, buffer.length, buffer.sampleRate);
      const source = offline.createBufferSource();
      source.buffer = buffer;
      const hp = offline.createBiquadFilter();
      hp.type = "highpass";
      hp.frequency.value = 140;
      hp.Q.value = 0.707;
      const lp = offline.createBiquadFilter();
      lp.type = "lowpass";
      lp.frequency.value = 5200;
      lp.Q.value = 0.707;
      source.connect(hp);
      hp.connect(lp);
      lp.connect(offline.destination);
      source.start(0);
      return offline.startRendering();
    }

    async function filterPianoBand(buffer) {
      const offline = new OfflineAudioContext(1, buffer.length, buffer.sampleRate);
      const source = offline.createBufferSource();
      source.buffer = buffer;
      const hp = offline.createBiquadFilter();
      hp.type = "highpass";
      hp.frequency.value = 120;
      hp.Q.value = 0.707;
      const lp = offline.createBiquadFilter();
      lp.type = "lowpass";
      lp.frequency.value = 6500;
      lp.Q.value = 0.707;
      source.connect(hp);
      hp.connect(lp);
      lp.connect(offline.destination);
      source.start(0);
      return offline.startRendering();
    }

    async function filterVocalBand(buffer) {
      const offline = new OfflineAudioContext(1, buffer.length, buffer.sampleRate);
      const source = offline.createBufferSource();
      source.buffer = buffer;
      const hp = offline.createBiquadFilter();
      hp.type = "highpass";
      hp.frequency.value = 160;
      hp.Q.value = 0.707;
      const lp = offline.createBiquadFilter();
      lp.type = "lowpass";
      lp.frequency.value = 3400;
      lp.Q.value = 0.707;
      source.connect(hp);
      hp.connect(lp);
      lp.connect(offline.destination);
      source.start(0);
      return offline.startRendering();
    }

    function analyzeOnsets(buffer, opts = {}) {
      const sensitivity = opts.sensitivity || 1;
      const mono = toMono(buffer);
      const emphasized = preEmphasis(mono);
      const sr = buffer.sampleRate;
      const frame = 1024;
      const hop = 512;
      const totalFrames = Math.floor((mono.length - frame) / hop);
      const energy = new Float32Array(totalFrames);

      for (let i = 0; i < totalFrames; i += 1) {
        const start = i * hop;
        let e = 0;
        for (let j = 0; j < frame; j += 1) {
          const v = emphasized[start + j];
          e += v * v;
        }
        energy[i] = Math.sqrt(e / frame);
      }

      const smooth = movingAverage(energy, 8);
      const novelty = new Float32Array(totalFrames);
      for (let i = 1; i < totalFrames; i += 1) {
        novelty[i] = Math.max(0, Math.log1p(smooth[i]) - Math.log1p(smooth[i - 1]));
      }

      const local = movingAverage(novelty, 30);
      let mean = 0;
      for (let i = 0; i < novelty.length; i += 1) mean += novelty[i];
      mean /= Math.max(1, novelty.length);
      let variance = 0;
      for (let i = 0; i < novelty.length; i += 1) {
        const d = novelty[i] - mean;
        variance += d * d;
      }
      const std = Math.sqrt(variance / Math.max(1, novelty.length));
      const peaks = [];
      let lastPeakTime = -999;
      for (let i = 2; i < novelty.length - 2; i += 1) {
        const th = local[i] * (1.4 / sensitivity) + std * (0.25 / sensitivity) + 0.0009 / sensitivity;
        const isPeak = novelty[i] > th &&
          novelty[i] > novelty[i - 1] &&
          novelty[i] >= novelty[i + 1];
        if (!isPeak) continue;

        const t = (i * hop) / sr;
        if (t - lastPeakTime < 0.075) continue;
        peaks.push({ t, v: novelty[i] });
        lastPeakTime = t;
      }
      return peaks;
    }

    function mergeOnsetsWeighted(lists, weights, mergeWindow = 0.045) {
      const all = [];
      for (const [mode, onsets] of Object.entries(lists)) {
        const w = weights[mode] || 1;
        for (const o of onsets) {
          all.push({ t: o.t, v: o.v * w });
        }
      }
      all.sort((a, b) => a.t - b.t);
      const merged = [];
      for (const o of all) {
        const last = merged[merged.length - 1];
        if (last && Math.abs(o.t - last.t) < mergeWindow) {
          last.t = (last.t * last.v + o.t * o.v) / (last.v + o.v);
          last.v += o.v;
        } else {
          merged.push({ t: o.t, v: o.v });
        }
      }
      return merged;
    }

    function parseMidi(arrayBuffer) {
      const data = new DataView(arrayBuffer);
      let idx = 0;
      const readStr = (n) => {
        let s = "";
        for (let i = 0; i < n; i += 1) s += String.fromCharCode(data.getUint8(idx++));
        return s;
      };
      const readU32 = () => {
        const v = data.getUint32(idx);
        idx += 4;
        return v;
      };
      const readU16 = () => {
        const v = data.getUint16(idx);
        idx += 2;
        return v;
      };
      const readVar = () => {
        let v = 0;
        while (true) {
          const b = data.getUint8(idx++);
          v = (v << 7) | (b & 0x7f);
          if ((b & 0x80) === 0) break;
        }
        return v;
      };

      if (readStr(4) !== "MThd") throw new Error("Invalid MIDI header");
      const headerLen = readU32();
      const format = readU16();
      const ntrks = readU16();
      const division = readU16();
      idx += Math.max(0, headerLen - 6);
      if (division & 0x8000) throw new Error("SMPTE MIDI not supported");
      const ticksPerBeat = division;

      const noteOns = [];
      const tempos = [];
      const timesigs = [];
      let maxTick = 0;
      const channelPrograms = new Array(16).fill(0);

      for (let t = 0; t < ntrks; t += 1) {
        if (readStr(4) !== "MTrk") throw new Error("Invalid MIDI track");
        const trackLen = readU32();
        const trackEnd = idx + trackLen;
        let tick = 0;
        let runningStatus = 0;
        while (idx < trackEnd) {
          const delta = readVar();
          tick += delta;
          if (tick > maxTick) maxTick = tick;
          let status = data.getUint8(idx++);
          let firstData = null;
          if (status < 0x80) {
            firstData = status;
            status = runningStatus;
          } else {
            runningStatus = status;
          }
          if (status === 0xff) {
            const type = data.getUint8(idx++);
            const len = readVar();
            if (type === 0x51 && len === 3) {
              const mpqn = (data.getUint8(idx) << 16) | (data.getUint8(idx + 1) << 8) | data.getUint8(idx + 2);
              tempos.push({ tick, mpqn });
            } else if (type === 0x58 && len >= 4) {
              const nn = data.getUint8(idx);
              const dd = data.getUint8(idx + 1);
              const denom = Math.pow(2, dd);
              timesigs.push({ tick, nn, denom });
            }
            idx += len;
            continue;
          }
          if (status === 0xf0 || status === 0xf7) {
            const len = readVar();
            idx += len;
            continue;
          }
          const type = status & 0xf0;
          const channel = status & 0x0f;
          const data1 = firstData !== null ? firstData : data.getUint8(idx++);
          const data2 = (type === 0xc0 || type === 0xd0) ? null : data.getUint8(idx++);
          if (type === 0xc0) {
            channelPrograms[channel] = data1;
          }
          if (type === 0x90 && data2 !== null && data2 > 0) {
            noteOns.push({
              tick,
              note: data1,
              vel: data2,
              ch: channel,
              prog: channelPrograms[channel] ?? 0
            });
          }
        }
      }

      if (!tempos.length) tempos.push({ tick: 0, mpqn: 500000 });
      tempos.sort((a, b) => a.tick - b.tick);
      if (tempos[0].tick !== 0) tempos.unshift({ tick: 0, mpqn: 500000 });

      const segments = [];
      let secAcc = 0;
      for (let i = 0; i < tempos.length; i += 1) {
        const cur = tempos[i];
        const next = tempos[i + 1];
        segments.push({ tick: cur.tick, sec: secAcc, mpqn: cur.mpqn });
        if (next) {
          const dt = next.tick - cur.tick;
          secAcc += (dt * cur.mpqn) / 1e6 / ticksPerBeat;
        }
      }

      const tickToSec = (tickVal) => {
        let seg = segments[0];
        for (let i = 0; i < segments.length; i += 1) {
          if (segments[i].tick <= tickVal) seg = segments[i];
          else break;
        }
        const dt = tickVal - seg.tick;
        return seg.sec + (dt * seg.mpqn) / 1e6 / ticksPerBeat;
      };

      const onsets = noteOns.map((n) => ({
        t: tickToSec(n.tick),
        v: n.vel / 127,
        note: n.note,
        ch: n.ch,
        prog: n.prog ?? 0
      }));

      const bpm = Math.round(60 * 1e6 / tempos[0].mpqn);
      let timeSig = null;
      if (timesigs.length) {
        const ts = timesigs.sort((a, b) => a.tick - b.tick)[0];
        timeSig = `${ts.nn}/${ts.denom}`;
      }
      const duration = tickToSec(maxTick);
      return { onsets, bpm, timeSig, duration };
    }

    function buildChartFromMidi(onsets, bpm, density) {
      if (!onsets.length) return [];
      const sorted = onsets.slice().sort((a, b) => a.t - b.t);
      const notes = [];
      const timeColor = new Map();
      const colorForTime = (t) => {
        const key = t.toFixed(3);
        if (!timeColor.has(key)) timeColor.set(key, toneColor());
        return timeColor.get(key);
      };
      let laneCursor = 0;
      const groupWindow = 0.02;
      let i = 0;
      while (i < sorted.length) {
        const t0 = sorted[i].t;
        const group = [];
        while (i < sorted.length && sorted[i].t - t0 <= groupWindow) {
          group.push(sorted[i]);
          i += 1;
        }
        if (Math.random() > density * 1.1) continue;
        group.sort((a, b) => a.note - b.note);
        const c = colorForTime(t0);
        if (group.length === 1) {
          const lane = laneCursor % laneCount;
          laneCursor += 1;
          notes.push({ t: t0, lane, type: "tap", color: c });
        } else {
          const count = Math.min(group.length, laneCount);
          for (let j = 0; j < count; j += 1) {
            const lane = count === 1 ? laneCursor % laneCount : Math.round(j * (laneCount - 1) / (count - 1));
            notes.push({ t: t0, lane, type: "tap", color: c });
          }
          laneCursor += 1;
        }
      }
      const target = 800;
      if (notes.length > target) {
        const ratio = target / notes.length;
        return notes.filter(() => Math.random() < ratio);
      }
      return injectHolds(notes, bpm);
    }

    function filterMidiOnsets(onsets, mode) {
      if (!onsets || !onsets.length) return [];
      const byChannel = new Map();
      for (const o of onsets) {
        const ch = o.ch ?? 0;
        if (!byChannel.has(ch)) byChannel.set(ch, []);
        byChannel.get(ch).push(o);
      }
      const counts = Array.from(byChannel.entries()).map(([ch, list]) => ({ ch, count: list.length }));
      counts.sort((a, b) => b.count - a.count);
      const drumCh = 9;
      const topMelody = counts.find((c) => c.ch !== drumCh) || counts[0];
      const secondMelody = counts.filter((c) => c.ch !== drumCh)[1];
      const pick = (chs) => {
        const filtered = [];
        for (const o of onsets) if (chs.has(o.ch ?? 0)) filtered.push(o);
        return filtered;
      };
      if (mode === "drums") return pick(new Set([drumCh]));
      if (mode === "drums_plus") {
        const set = new Set([drumCh]);
        if (topMelody) set.add(topMelody.ch);
        return pick(set);
      }
      if (mode === "melody") return pick(new Set([topMelody?.ch ?? 0]));
      if (mode === "melody_harmony") {
        const set = new Set([topMelody?.ch ?? 0]);
        if (secondMelody) set.add(secondMelody.ch);
        return pick(set);
      }
      if (mode === "auto") {
        const set = new Set([topMelody?.ch ?? 0]);
        const drumCount = counts.find((c) => c.ch === drumCh)?.count || 0;
        if (drumCount > (topMelody?.count || 0) * 0.35) set.add(drumCh);
        return pick(set);
      }
      return onsets;
    }

    function classifyProgram(prog) {
      if (prog >= 0 && prog <= 7) return "piano";
      if (prog >= 24 && prog <= 31) return "guitar";
      if (prog >= 32 && prog <= 39) return "bass";
      if (prog >= 80 && prog <= 87) return "lead";
      return "other";
    }

    function pickDominantProgram(progCounts) {
      let best = 0;
      let bestCount = -1;
      for (const [prog, count] of progCounts.entries()) {
        if (count > bestCount) {
          best = prog;
          bestCount = count;
        }
      }
      return best;
    }

    function selectMidiPlaybackOnsets(onsets, durationSec) {
      if (!onsets || !onsets.length) return [];
      const byChannel = new Map();
      for (const o of onsets) {
        const ch = o.ch ?? 0;
        if (ch === 9) continue;
        let info = byChannel.get(ch);
        if (!info) {
          info = {
            ch,
            notes: [],
            count: 0,
            sumPitch: 0,
            sumVel: 0,
            minPitch: 128,
            maxPitch: 0,
            progCounts: new Map()
          };
          byChannel.set(ch, info);
        }
        info.notes.push(o);
        info.count += 1;
        info.sumPitch += o.note;
        info.sumVel += o.v ?? 0.6;
        if (o.note < info.minPitch) info.minPitch = o.note;
        if (o.note > info.maxPitch) info.maxPitch = o.note;
        const prog = o.prog ?? 0;
        info.progCounts.set(prog, (info.progCounts.get(prog) || 0) + 1);
      }

      const channels = Array.from(byChannel.values()).map((info) => {
        const avgPitch = info.sumPitch / info.count;
        const avgVel = info.sumVel / info.count;
        const range = info.maxPitch - info.minPitch;
        const domProg = pickDominantProgram(info.progCounts);
        const type = classifyProgram(domProg);
        return { ...info, avgPitch, avgVel, range, domProg, type };
      });
      if (!channels.length) return [];

      let bass = channels.filter((c) => c.type === "bass");
      let bassCh = null;
      if (bass.length) {
        bass.sort((a, b) => b.count - a.count);
        bassCh = bass[0].ch;
      } else {
        const sorted = channels.slice().sort((a, b) => a.avgPitch - b.avgPitch);
        bassCh = sorted[0].ch;
      }

      const leadCandidates = channels.filter((c) => c.type === "lead");
      let melodyCh = null;
      if (leadCandidates.length) {
        leadCandidates.sort((a, b) => b.count - a.count);
        melodyCh = leadCandidates[0].ch;
      } else {
        const melodyCandidates = channels
          .filter((c) => c.ch !== bassCh)
          .sort((a, b) => {
            const sa = a.avgPitch * 0.8 + a.count * 0.2;
            const sb = b.avgPitch * 0.8 + b.count * 0.2;
            return sb - sa;
          });
        melodyCh = melodyCandidates[0]?.ch ?? bassCh;
      }

      let instrCandidates = channels.filter((c) => c.type === "piano" || c.type === "guitar");
      instrCandidates = instrCandidates.filter((c) => c.ch !== melodyCh && c.ch !== bassCh);
      instrCandidates.sort((a, b) => b.count - a.count);
      let instrCh = instrCandidates[0]?.ch ?? null;

      const selected = new Set([melodyCh, bassCh, instrCh].filter((v) => v !== null && v !== undefined));
      const picked = [];
      for (const o of onsets) {
        const ch = o.ch ?? 0;
        if (selected.has(ch)) picked.push(o);
      }
      return picked.sort((a, b) => a.t - b.t);
    }

    function estimateBpmFromOnsets(onsets) {
      if (onsets.length < 8) return 120;
      const diffs = [];
      for (let i = 1; i < onsets.length; i += 1) {
        const d = onsets[i].t - onsets[i - 1].t;
        if (d > 0.18 && d < 1.0) diffs.push(d);
      }
      if (!diffs.length) return 120;

      const bins = new Map();
      for (const d of diffs) {
        const bpmA = 60 / d;
        const candidates = [bpmA, bpmA * 2, bpmA / 2];
        for (let bpm of candidates) {
          while (bpm < 70) bpm *= 2;
          while (bpm > 190) bpm /= 2;
          const key = Math.round(bpm);
          bins.set(key, (bins.get(key) || 0) + 1);
        }
      }

      let best = 120;
      let bestCount = -1;
      for (const [b, count] of bins.entries()) {
        if (count > bestCount) {
          bestCount = count;
          best = b;
        }
      }
      return Math.min(190, Math.max(70, best));
    }

    function quantize(value, step) {
      return Math.round(value / step) * step;
    }

    function estimateBeatPhase(onsets, bpm) {
      if (onsets.length < 6) return 0;
      const beat = 60 / bpm;
      const grid = beat / 4;
      const sigma = grid * 0.22;
      let bestOffset = 0;
      let bestScore = -1;
      const samples = 24;
      for (let i = 0; i < samples; i += 1) {
        const offset = (i / samples) * grid;
        let score = 0;
        for (const o of onsets) {
          const pos = (o.t - offset) % grid;
          const dist = Math.min(pos, grid - pos);
          const w = 0.6 + Math.min(1, o.v * 8);
          score += Math.exp(-(dist * dist) / (2 * sigma * sigma)) * w;
        }
        if (score > bestScore) {
          bestScore = score;
          bestOffset = offset;
        }
      }
      return bestOffset;
    }

    function parseTimeSig(value) {
      if (value === "4/4") return { beats: 4, label: "4/4" };
      if (value === "3/4") return { beats: 3, label: "3/4" };
      if (value === "7/8") return { beats: 3.5, label: "7/8" };
      if (value === "6/8") return { beats: 3, label: "6/8" };
      if (value === "9/8") return { beats: 4.5, label: "9/8" };
      if (value === "5/4") return { beats: 5, label: "5/4" };
      if (value === "12/8") return { beats: 6, label: "12/8" };
      return { beats: 4, label: "自动" };
    }

    function estimateTimeSignature(onsets, bpm) {
      const beat = 60 / bpm;
      const candidates = [
        { beats: 4, label: "4/4" },
        { beats: 3, label: "3/4" },
        { beats: 3.5, label: "7/8" },
        { beats: 3, label: "6/8" },
        { beats: 4.5, label: "9/8" },
        { beats: 5, label: "5/4" }
        ,
        { beats: 6, label: "12/8" }
      ];

      let best = candidates[0];
      let bestScore = -1;
      const bins = 16;
      for (const c of candidates) {
        const barSec = beat * c.beats;
        const hist = new Array(bins).fill(0);
        let total = 0;
        for (const o of onsets) {
          const pos = (o.t % barSec) / barSec;
          const idx = Math.floor(pos * bins);
          hist[idx] += o.v;
          total += o.v;
        }
        if (total <= 0) continue;
        const maxBin = Math.max(...hist);
        const score = maxBin / total;
        if (score > bestScore) {
          bestScore = score;
          best = c;
        }
      }
      return best;
    }

    function buildChartFromOnsets(onsets, bpm, density, phaseOffset = 0, lock = 0.65) {
      if (!onsets.length) return [];
      const beat = 60 / bpm;
      const grid = beat / 4;
      const maxV = onsets.reduce((m, o) => Math.max(m, o.v), 0) || 1;
      const quantized = [];
      let last = -999;
      let lane = 0;

      for (const o of onsets) {
        const q = Math.round((o.t - phaseOffset) / grid) * grid + phaseOffset;
        const dist = Math.abs(o.t - q);
        const t = dist <= grid * 0.45 ? (o.t * (1 - lock) + q * lock) : o.t;
        if (t - last < grid * 0.5) continue;
        const keepProb = Math.min(1, density * (0.55 + (o.v / maxV) * 0.9));
        if (Math.random() > keepProb) continue;
        quantized.push({ t, v: o.v });
        last = t;
      }

      const notes = [];
      const timeColor = new Map();
      const colorForTime = (t) => {
        const key = t.toFixed(3);
        if (!timeColor.has(key)) timeColor.set(key, toneColor());
        return timeColor.get(key);
      };
      for (let i = 0; i < quantized.length; i += 1) {
        const n = quantized[i];
        const strong = n.v > maxV * 0.45;
        const makeChord = strong && i % 8 === 0;
        if (makeChord) {
          lane = (lane + 1) % laneCount;
          const other = (lane + 2) % laneCount;
          const c = colorForTime(n.t);
          notes.push({ t: n.t, lane, type: "tap", color: c });
          notes.push({ t: n.t, lane: other, type: "tap", color: c });
          continue;
        }
        lane = (lane + 1 + (i % 2)) % laneCount;
        notes.push({ t: n.t, lane, type: "tap", color: colorForTime(n.t) });
      }
      return injectHolds(notes.sort((a, b) => a.t - b.t), bpm);
    }

    function injectHolds(notes, bpm) {
      if (!notes.length) return notes;
      const beat = 60 / bpm;
      const byLane = new Map();
      for (const n of notes) {
        if (!byLane.has(n.lane)) byLane.set(n.lane, []);
        byLane.get(n.lane).push(n);
      }
      const result = [];
      for (const [lane, list] of byLane.entries()) {
        list.sort((a, b) => a.t - b.t);
        for (let i = 0; i < list.length; i += 1) {
          const cur = list[i];
          const next = list[i + 1];
          if (next) {
            const gap = next.t - cur.t;
            const wantHold = gap >= beat * 0.7 && gap <= beat * 3.5;
            if (wantHold && Math.random() < 0.32) {
              result.push({
                ...cur,
                type: "hold",
                end: next.t - 0.05,
                color: cur.color
              });
              list.splice(i + 1, 1); // consume next as tail
              continue;
            }
          }
          result.push(cur);
        }
      }
      let holds = result.filter((n) => n.type === "hold").length;
      if (holds === 0 && result.length >= 2) {
        const sorted = result.slice().sort((a, b) => a.t - b.t);
        let fallback = null;
        for (let i = 0; i < sorted.length - 1; i += 1) {
          const a = sorted[i];
          const b = sorted[i + 1];
          if (a.lane === b.lane && b.t - a.t >= beat * 0.9) {
            fallback = { a, b };
            break;
          }
        }
        if (!fallback) {
          fallback = { a: sorted[0], b: sorted[1] };
        }
        const { a, b } = fallback;
        const endT = Math.min(b.t - 0.05, a.t + beat * 2.2);
        result.push({
          ...a,
          type: "hold",
          end: endT,
          color: a.color
        });
      }
      holds = result.filter((n) => n.type === "hold").length;
      const minHoldCount = result.length >= 12 ? 1 : 0;
      const maxHoldCount = Math.max(minHoldCount, Math.floor(result.length * 0.15));
      if (holds > maxHoldCount) {
        const holdIdx = [];
        for (let i = 0; i < result.length; i += 1) {
          const n = result[i];
          if (n.type === "hold") {
            holdIdx.push({ i, dur: Math.max(0.01, (n.end || n.t) - n.t) });
          }
        }
        holdIdx.sort((a, b) => b.dur - a.dur);
        const keep = new Set(holdIdx.slice(0, maxHoldCount).map((x) => x.i));
        for (const h of holdIdx) {
          if (keep.has(h.i)) continue;
          const n = result[h.i];
          n.type = "tap";
          delete n.end;
        }
      }
      return result.sort((a, b) => a.t - b.t);
    }

    function chooseSegments(modes, barSec) {
      const barScores = [];
      let maxT = 0;
      for (const [mode, onsets] of Object.entries(modes)) {
        for (const o of onsets) {
          const idx = Math.floor(o.t / barSec);
          if (!barScores[idx]) barScores[idx] = {};
          barScores[idx][mode] = (barScores[idx][mode] || 0) + o.v;
          if (o.t > maxT) maxT = o.t;
        }
      }

      const bars = Math.max(1, Math.ceil(maxT / barSec));
      const barModes = [];
      for (let i = 0; i < bars; i += 1) {
        const bucket = barScores[i] || {};
        let bestMode = Object.keys(modes)[0] || "drum";
        let bestScore = -1;
        for (const mode of Object.keys(modes)) {
          const value = bucket[mode] || 0;
          if (value > bestScore) {
            bestScore = value;
            bestMode = mode;
          }
        }
        barModes[i] = bestMode;
      }

      const smoothed = barModes.map((mode, i) => {
        const window = [barModes[i - 1], barModes[i], barModes[i + 1]].filter(Boolean);
        const counts = {};
        for (const m of window) counts[m] = (counts[m] || 0) + 1;
        let best = mode;
        let bestCount = -1;
        for (const m of Object.keys(counts)) {
          if (counts[m] > bestCount) {
            bestCount = counts[m];
            best = m;
          }
        }
        return best;
      });

      const segments = [];
      let startBar = 0;
      for (let i = 1; i <= smoothed.length; i += 1) {
        if (i === smoothed.length || smoothed[i] !== smoothed[i - 1]) {
          segments.push({
            mode: smoothed[i - 1],
            start: startBar * barSec,
            end: i * barSec,
            bars: i - startBar
          });
          startBar = i;
        }
      }

      // Merge too-short segments into neighbors to avoid jitter.
      const merged = [];
      for (const seg of segments) {
        if (merged.length === 0) {
          merged.push(seg);
          continue;
        }
        if (seg.bars < 2) {
          merged[merged.length - 1].end = seg.end;
          merged[merged.length - 1].bars += seg.bars;
        } else {
          merged.push(seg);
        }
      }
      return merged;
    }

    function detectSections(onsets, barSec) {
      const bars = Math.max(1, Math.ceil(onsets[onsets.length - 1]?.t / barSec || 1));
      const energy = new Array(bars).fill(0);
      for (const o of onsets) {
        const idx = Math.floor(o.t / barSec);
        if (idx >= 0 && idx < bars) energy[idx] += o.v;
      }
      const smooth = energy.map((_, i) => {
        const a = energy[i - 1] || 0;
        const b = energy[i] || 0;
        const c = energy[i + 1] || 0;
        return (a + b * 2 + c) / 4;
      });
      const sections = [];
      let start = 0;
      for (let i = 1; i < bars; i += 1) {
        const prev = smooth[i - 1] || 1e-6;
        const curr = smooth[i] || 1e-6;
        const ratio = curr / prev;
        const longEnough = i - start >= 3;
        if (longEnough && (ratio > 1.6 || ratio < 0.6)) {
          sections.push({ startBar: start, endBar: i });
          start = i;
        }
      }
      sections.push({ startBar: start, endBar: bars });
      return sections;
    }

    function buildChartAuto(modes, bpm, density, phaseOffset, lock, barSec) {
      const segments = chooseSegments(modes, barSec);
      const sectionEnergy = detectSections(modes.mix || [], barSec);
      const overallEnergy = (modes.mix || []).reduce((s, o) => s + o.v, 0) / Math.max(1, sectionEnergy.length);
      const barBins = 16;
      const buildTemplate = (onsets) => {
        if (!onsets.length) return [];
        const counts = new Map();
        for (const o of onsets) {
          const pos = (o.t % barSec) / barSec;
          const bin = Math.round(pos * barBins);
          const key = Math.max(0, Math.min(barBins, bin));
          counts.set(key, (counts.get(key) || 0) + 1);
        }
        const max = Math.max(...counts.values());
        const template = [];
        for (const [k, v] of counts.entries()) {
          if (v >= max * 0.65) template.push(k / barBins);
        }
        return template.sort((a, b) => a - b);
      };

      const templates = sectionEnergy.map((sec) => {
        const onsets = (modes.mix || []).filter((o) => {
          const bar = Math.floor(o.t / barSec);
          return bar >= sec.startBar && bar < sec.endBar;
        });
        return buildTemplate(onsets);
      });

      const sectionIndexForBar = (bar) => {
        for (let i = 0; i < sectionEnergy.length; i += 1) {
          const sec = sectionEnergy[i];
          if (bar >= sec.startBar && bar < sec.endBar) return i;
        }
        return 0;
      };

      const merged = [];
      for (const seg of segments) {
        const segBarStart = Math.floor(seg.start / barSec);
        const sec = sectionEnergy.find((s) => segBarStart >= s.startBar && segBarStart < s.endBar) || sectionEnergy[0];
        const secOnsets = (modes.mix || []).filter((o) => {
          const bar = Math.floor(o.t / barSec);
          return bar >= sec.startBar && bar < sec.endBar;
        });
        const secEnergy = secOnsets.reduce((s, o) => s + o.v, 0) / Math.max(1, sec.endBar - sec.startBar);
        const scale = overallEnergy > 0 ? Math.min(1.25, Math.max(0.8, secEnergy / overallEnergy)) : 1;
        const segDensity = density * scale;
        const onsets = (modes[seg.mode] || []).filter((o) => o.t >= seg.start && o.t < seg.end);
        const chunk = buildChartFromOnsets(onsets, bpm, segDensity, phaseOffset, lock);
        // Align rhythm to section template when close.
        for (const n of chunk) {
          const bar = Math.floor(n.t / barSec);
          const idx = sectionIndexForBar(bar);
          const template = templates[idx] || [];
          if (!template.length) continue;
          const pos = (n.t % barSec) / barSec;
          let best = pos;
          let bestDist = 1;
          for (const tPos of template) {
            const d = Math.abs(pos - tPos);
            if (d < bestDist) {
              bestDist = d;
              best = tPos;
            }
          }
          if (bestDist <= 0.08) {
            n.t = bar * barSec + best * barSec;
          }
        }
        for (const n of chunk) merged.push(n);
      }
      return merged.sort((a, b) => a.t - b.t);
    }

    function roundRectPath(ctx2d, x, y, w, h, r) {
      const rr = Math.max(0, Math.min(r, w * 0.5, h * 0.5));
      ctx2d.beginPath();
      ctx2d.moveTo(x + rr, y);
      ctx2d.lineTo(x + w - rr, y);
      ctx2d.quadraticCurveTo(x + w, y, x + w, y + rr);
      ctx2d.lineTo(x + w, y + h - rr);
      ctx2d.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
      ctx2d.lineTo(x + rr, y + h);
      ctx2d.quadraticCurveTo(x, y + h, x, y + h - rr);
      ctx2d.lineTo(x, y + rr);
      ctx2d.quadraticCurveTo(x, y, x + rr, y);
      ctx2d.closePath();
    }

    function pushParticle(p) {
      if (particles.length >= MAX_PARTICLES) return;
      particles.push(p);
    }

    function drawLuxNote(x, y, w, h, color, glow = 1) {
      g.save();
      const grad = g.createLinearGradient(x, y, x, y + h);
      grad.addColorStop(0, "rgba(255,255,255,0.24)");
      grad.addColorStop(0.24, color);
      grad.addColorStop(1, "rgba(170,188,206,0.9)");
      g.shadowBlur = 12 * glow;
      g.shadowColor = "rgba(236,244,255,0.42)";
      roundRectPath(g, x, y, w, h, 7);
      g.fillStyle = grad;
      g.fill();
      g.shadowBlur = 0;
      g.strokeStyle = "rgba(250,252,255,0.26)";
      g.lineWidth = 1;
      roundRectPath(g, x + 0.5, y + 0.5, w - 1, h - 1, 6.5);
      g.stroke();
      g.restore();
    }

    function render(currentTime = 0) {
      const { width, height, judgeY } = gameState;
      g.clearRect(0, 0, width, height);

      g.fillStyle = "rgba(11, 16, 24, 0.5)";
      g.fillRect(0, 0, width, height);

      const laneWidth = width / laneCount;
      for (let lane = 0; lane < laneCount; lane += 1) {
        g.fillStyle = lane % 2 === 0 ? "rgba(16, 24, 38, 0.44)" : "rgba(14, 22, 34, 0.4)";
        g.fillRect(lane * laneWidth, 0, laneWidth, height);

        g.strokeStyle = "rgba(37, 50, 68, 0.45)";
        g.lineWidth = 1;
        g.beginPath();
        g.moveTo(lane * laneWidth, 0);
        g.lineTo(lane * laneWidth, height);
        g.stroke();

        const flashAge = currentTime - laneFlash[lane];
        if (flashAge >= 0 && flashAge < FLASH_DURATION) {
          const alpha = 1 - flashAge / FLASH_DURATION;
          const x0 = lane * laneWidth;
          const laneGrad = g.createLinearGradient(0, 0, 0, height);
          laneGrad.addColorStop(0, `rgba(0,0,0,0)`);
          laneGrad.addColorStop(0.58, `rgba(206, 220, 236, ${0.06 * alpha})`);
          laneGrad.addColorStop(0.88, `rgba(206, 220, 236, ${0.14 * alpha})`);
          laneGrad.addColorStop(1, `rgba(0,0,0,0)`);
          g.fillStyle = laneGrad;
          g.fillRect(x0, 0, laneWidth, height);

          const judgeGrad = g.createLinearGradient(0, judgeY - 34, 0, judgeY + 34);
          judgeGrad.addColorStop(0, `rgba(0,0,0,0)`);
          judgeGrad.addColorStop(0.32, `rgba(255, 242, 206, ${0.08 * alpha})`);
          judgeGrad.addColorStop(0.5, `rgba(242, 248, 255, ${0.24 * alpha})`);
          judgeGrad.addColorStop(0.68, `rgba(255, 242, 206, ${0.08 * alpha})`);
          judgeGrad.addColorStop(1, `rgba(0,0,0,0)`);
          g.fillStyle = judgeGrad;
          g.fillRect(x0, judgeY - 34, laneWidth, 68);
        }
      }

      g.strokeStyle = "rgba(37, 50, 68, 0.45)";
      g.beginPath();
      g.moveTo(width, 0);
      g.lineTo(width, height);
      g.stroke();

      g.fillStyle = "rgba(144, 160, 176, 0.28)";
      g.fillRect(0, judgeY - 2, width, 4);

      if (currentTime < lastRenderTime) renderStartIndex = 0;
      lastRenderTime = currentTime;

      while (renderStartIndex < chart.length) {
        const n = chart[renderStartIndex];
        const nEnd = (n.type === "hold" ? n.end : n.t) + offsetSec;
        if (nEnd < currentTime - 0.4) {
          renderStartIndex += 1;
        } else {
          break;
        }
      }

      for (let i = renderStartIndex; i < chart.length; i += 1) {
        const note = chart[i];
        if (note.hit) continue;
        const dt = (note.t + offsetSec) - currentTime;
        if (dt > scrollTime) break;
        const x = note.lane * laneWidth + 12;
        const w = laneWidth - 24;
        const color = note.color || laneColor(note.lane);
        if (note.type === "hold") {
          const endDt = (note.end + offsetSec) - currentTime;
          if (endDt < -hitWindow) continue;
          const holdActive = !!(activeHolds[note.lane] && activeHolds[note.lane].note === note);
          const yHead = holdActive ? judgeY : (judgeY - (dt / scrollTime) * (height - 40));
          const yTail = judgeY - (endDt / scrollTime) * (height - 40);
          const y0 = Math.min(yHead, yTail);
          const y1 = Math.max(yHead, yTail);
          const bodyH = Math.max(12, y1 - y0);
          const bodyGrad = g.createLinearGradient(x, y0, x + w, y0);
          bodyGrad.addColorStop(0, "rgba(238,246,255,0.04)");
          bodyGrad.addColorStop(0.5, "rgba(196,216,236,0.2)");
          bodyGrad.addColorStop(1, "rgba(255,236,190,0.08)");
          g.fillStyle = bodyGrad;
          roundRectPath(g, x + 3, y0, w - 6, bodyH, 7);
          g.fill();
          g.strokeStyle = "rgba(244,249,255,0.12)";
          g.lineWidth = 1;
          roundRectPath(g, x + 3.5, y0 + 0.5, w - 7, bodyH - 1, 6.5);
          g.stroke();
          if (!holdActive) {
            drawLuxNote(x, yHead - 10, w, 18, color, 1.05);
          }
          // tail cap
          drawLuxNote(x + 4, yTail - 8, w - 8, 12, "rgba(232,240,248,0.7)", 0.8);
        } else {
          const y = judgeY - (dt / scrollTime) * (height - 40);
          drawLuxNote(x, y - 9, w, 18, color, 1);
        }
      }

      // Particle sparkles.
      g.save();
      g.globalCompositeOperation = "lighter";
      const lightweightParticles = particles.length > HEAVY_PARTICLE_THRESHOLD;
      for (let i = particles.length - 1; i >= 0; i -= 1) {
        const p = particles[i];
        const age = currentTime - p.t;
        if (age > p.life) {
          particles.splice(i, 1);
          continue;
        }
        const alpha = 1 - age / p.life;
        const px = p.x + p.vx * age;
        const py = p.y + p.vy * age + 80 * age * age;
        if (p.kind === "ring") {
          const rr = p.r + age * (p.expand || 100);
          g.strokeStyle = p.tint === "gold"
            ? `rgba(255, 228, 172, ${0.34 * alpha})`
            : `rgba(240, 246, 255, ${0.34 * alpha})`;
          g.lineWidth = 0.9 + alpha * 1.2;
          g.beginPath();
          g.arc(px, py, rr, 0, Math.PI * 2);
          g.stroke();
        } else {
          const gold = p.tint === "gold";
          const rr = p.r * (0.95 + 0.55 * alpha);
          if (lightweightParticles) {
            g.fillStyle = gold
              ? `rgba(255, 236, 192, ${0.62 * alpha})`
              : `rgba(242, 248, 255, ${0.62 * alpha})`;
            g.beginPath();
            g.arc(px, py, rr * 0.95, 0, Math.PI * 2);
            g.fill();
          } else {
            const grad = g.createRadialGradient(px, py, 0, px, py, rr * 2.4);
            if (gold) {
              grad.addColorStop(0, `rgba(255, 247, 228, ${0.92 * alpha})`);
              grad.addColorStop(0.32, `rgba(255, 226, 166, ${0.56 * alpha})`);
              grad.addColorStop(1, `rgba(255, 210, 120, 0)`);
            } else {
              grad.addColorStop(0, `rgba(255, 255, 255, ${0.95 * alpha})`);
              grad.addColorStop(0.34, `rgba(228, 242, 255, ${0.56 * alpha})`);
              grad.addColorStop(1, `rgba(196, 220, 242, 0)`);
            }
            g.shadowBlur = 10;
            g.shadowColor = gold
              ? `rgba(255, 218, 148, ${0.45 * alpha})`
              : `rgba(230, 242, 255, ${0.45 * alpha})`;
            g.fillStyle = grad;
            g.beginPath();
            g.arc(px, py, rr * 2.4, 0, Math.PI * 2);
            g.fill();
            g.fillStyle = gold
              ? `rgba(255, 244, 220, ${0.72 * alpha})`
              : `rgba(252, 255, 255, ${0.74 * alpha})`;
            g.beginPath();
            g.arc(px, py, rr * 0.78, 0, Math.PI * 2);
            g.fill();
            g.shadowBlur = 0;
          }
        }
      }
      g.restore();
    }

    function updateMisses(currentTime) {
      while (nextMissIndex < chart.length) {
        const n = chart[nextMissIndex];
        if (n.hit) {
          nextMissIndex += 1;
          continue;
        }
        if (n.type === "hold") {
          const endTime = n.end + offsetSec;
          const startTimeLocal = n.t + offsetSec;
          if (currentTime - endTime > hitWindow) {
            // Missed tail.
            n.hit = true;
            const ahMiss = activeHolds[n.lane];
            if (ahMiss) stopHoldSustain(ahMiss);
            activeHolds[n.lane] = null;
            combo = 0;
            ui.combo.textContent = "0";
            nextMissIndex += 1;
            continue;
          }
          // Auto-complete if still holding past end.
          const ah = activeHolds[n.lane];
          if (ah && ah.note === n && currentTime >= endTime) {
            finishHoldSuccess(n, false);
            nextMissIndex += 1;
            continue;
          }
          if (currentTime < startTimeLocal - hitWindow) break;
          // not miss yet, wait.
          break;
        } else {
          if (currentTime - (n.t + offsetSec) > hitWindow) {
            n.hit = true;
            combo = 0;
            ui.combo.textContent = "0";
            nextMissIndex += 1;
            continue;
          }
          if (currentTime < n.t + offsetSec - hitWindow) break;
          break;
        }
      }
    }

    function loop() {
      if (!running) return;
      lastFrameTs = performance.now();
      const t = ctx.currentTime - startTime;
      for (let lane = 0; lane < laneCount; lane += 1) {
        const ah = activeHolds[lane];
        if (!ah) continue;
        if (!ah.lastTrail || t - ah.lastTrail > 0.065) {
          spawnHoldTrail(lane, t);
          ah.lastTrail = t;
        }
      }
      updateMisses(t);
      render(t);
      rafId = requestAnimationFrame(loop);
    }

    function spawnParticles(lane, perfect, t) {
      const laneWidth = gameState.width / laneCount;
      const baseX = lane * laneWidth + laneWidth / 2;
      const baseY = gameState.judgeY - 6;
      const budget = Math.max(4, MAX_PARTICLES - particles.length);
      const count = Math.min(budget, perfect ? 16 : 12);
      for (let i = 0; i < count; i += 1) {
        const angle = Math.random() * Math.PI * 2;
        const speed = (Math.random() * 78 + 58) * (perfect ? 1.08 : 1);
        const tint = Math.random() < 0.34 ? "gold" : "white";
        pushParticle({
          x: baseX + (Math.random() * 16 - 8),
          y: baseY + (Math.random() * 6 - 3),
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - 40,
          r: Math.random() * 1.7 + 0.9,
          tint,
          t,
          life: 0.32 + Math.random() * 0.14
        });
      }
      if (budget > count + 2) {
        pushParticle({
          kind: "ring",
          tint: "white",
          x: baseX,
          y: baseY,
          vx: 0,
          vy: 0,
          r: perfect ? 8 : 6.5,
          expand: perfect ? 120 : 98,
          t,
          life: perfect ? 0.18 : 0.15
        });
      }
    }

    function spawnHoldTrail(lane, t) {
      const laneWidth = gameState.width / laneCount;
      const x = lane * laneWidth + laneWidth / 2;
      const y = gameState.judgeY - 6;
      for (let i = 0; i < 3; i += 1) {
        const angle = (Math.random() - 0.5) * Math.PI;
        const speed = 22 + Math.random() * 24;
        pushParticle({
          x: x + (Math.random() * 10 - 5),
          y: y + (Math.random() * 4 - 2),
          vx: Math.cos(angle) * speed,
          vy: -Math.abs(Math.sin(angle) * speed) - 12,
          r: 0.9 + Math.random() * 1.1,
          tint: Math.random() < 0.3 ? "gold" : "white",
          t,
          life: 0.16 + Math.random() * 0.09
        });
      }
    }

    function finishHoldSuccess(note, silent = false) {
      const ah = activeHolds[note.lane];
      if (ah) stopHoldSustain(ah);
      note.hit = true;
      activeHolds[note.lane] = null;
      if (silent) return;
      combo += 1;
      ui.combo.textContent = String(combo);
      const gain = 160;
      score += gain + combo * 2;
      ui.score.textContent = String(score);
      playHitSound("good");
      spawnParticles(note.lane, false, ctx.currentTime - startTime);
    }

    function hitLane(lane) {
      if (!running) return;
      const t = ctx.currentTime - startTime;
      laneFlash[lane] = t;
      playHitSound("tap");

      let bestIndex = -1;
      let bestDelta = Infinity;

      for (let i = nextMissIndex; i < chart.length; i += 1) {
        const n = chart[i];
        if (n.hit) continue;
        if (n.lane !== lane) continue;
        const d = Math.abs(t - (n.t + offsetSec));
        if (d < bestDelta) {
          bestDelta = d;
          bestIndex = i;
        }
        if ((n.t + offsetSec) - t > hitWindow) break;
      }

      if (bestIndex >= 0 && bestDelta <= hitWindow) {
        const note = chart[bestIndex];
        if (note.type === "hold") {
          // start hold
          activeHolds[lane] = { note, start: t, lastTrail: t };
          activeHolds[lane].sustain = startHoldSustain(lane, note);
          // award head only (once)
          const perfect = bestDelta <= perfectWindow;
          const gain = perfect ? 280 : 180;
          score += gain + combo * 2;
          ui.score.textContent = String(score);
          combo += 1;
          ui.combo.textContent = String(combo);
          laneFlash[lane] = t;
          spawnParticles(lane, perfect, t);
        } else {
          note.hit = true;
          const perfect = bestDelta <= perfectWindow;
          const gain = perfect ? 300 : 180;
          score += gain + combo * 2;
          ui.score.textContent = String(score);
          laneFlash[lane] = t;
          playHitSound(perfect ? "perfect" : "good");
          combo += 1;
          ui.combo.textContent = String(combo);
          spawnParticles(lane, perfect, t);
        }
      } else {
        combo = 0;
        ui.combo.textContent = "0";
      }
    }

    function releaseLane(lane) {
      if (!running) return;
      const ah = activeHolds[lane];
      const t = ctx.currentTime - startTime;
      if (!ah) return;
      const endTime = ah.note.end + offsetSec;
      if (t >= endTime - hitWindow) {
        finishHoldSuccess(ah.note);
      } else {
        // early release -> miss
        stopHoldSustain(ah);
        ah.note.hit = true;
        activeHolds[lane] = null;
        combo = 0;
        ui.combo.textContent = "0";
      }
      while (nextMissIndex < chart.length && chart[nextMissIndex].hit) nextMissIndex += 1;
    }

    async function loadAudio(file) {
      const audioCtx = ensureAudioContext();
      const data = await file.arrayBuffer();
      return audioCtx.decodeAudioData(data.slice(0));
    }

    async function loadSample() {
      stopGame();
      resetScore();
      setStatus(t("status_analyzing"));
      try {
        const res = await fetch("assets/HaMfin.wav");
        const buf = await res.arrayBuffer();
        audioBuffer = await ensureAudioContext().decodeAudioData(buf.slice(0));
        fileName = "HaM - Haze_zzZ";
        currentSource = "audio";
        ui.analyze.disabled = false;
        ui.bpm.textContent = "-";
        ui.notes.textContent = "-";
        ui.keyStat.textContent = "-";
        ui.hold.textContent = "0";
        ui.chord.textContent = "0";
        setStatus(t("status_loaded", fileName));
      } catch (err) {
        setStatus(`Sample load failed: ${err.message || err}`, true);
      }
    }

    async function startRecording() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        recordChunks = [];
        recorder = new MediaRecorder(stream);
        recorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) recordChunks.push(e.data);
        };
        recorder.onstop = async () => {
          if (recordTimeout) {
            clearTimeout(recordTimeout);
            recordTimeout = null;
          }
          if (recordInterval) {
            clearInterval(recordInterval);
            recordInterval = null;
          }
          ui.recordTimer.textContent = "60s";
          const blob = new Blob(recordChunks, { type: recorder.mimeType });
          const buf = await blob.arrayBuffer();
          audioBuffer = await ensureAudioContext().decodeAudioData(buf.slice(0));
          fileName = "Mic Recording";
          currentSource = "audio";
          ui.analyze.disabled = false;
          ui.bpm.textContent = "-";
          ui.notes.textContent = "-";
          ui.keyStat.textContent = "-";
          setStatus(t("status_record_done"));
          ui.record.disabled = false;
          ui.stopRecord.disabled = true;
          stream.getTracks().forEach((t) => t.stop());
        };
        recorder.start();
        let remaining = 60;
        ui.recordTimer.textContent = `${remaining}s`;
        recordInterval = setInterval(() => {
          remaining -= 1;
          if (remaining <= 0) {
            remaining = 0;
            clearInterval(recordInterval);
            recordInterval = null;
          }
          ui.recordTimer.textContent = `${remaining}s`;
        }, 1000);
        recordTimeout = setTimeout(() => {
          if (recorder && recorder.state !== "inactive") {
            recorder.stop();
          }
        }, 60000);
        ui.record.disabled = true;
        ui.stopRecord.disabled = false;
        setStatus(t("status_recording"));
      } catch (err) {
        setStatus(`Recording failed: ${err.message || err}`, true);
      }
    }

    function stopRecording() {
      if (recorder && recorder.state !== "inactive") {
        recorder.stop();
      }
    }

    async function doAnalyze() {
      if (!audioBuffer && !midiOnsets) return;
      stopGame();
      resetScore();
      setStatus(t("status_analyzing"));
      render(0);

      await new Promise((r) => setTimeout(r, 30));
      if (currentSource === "midi" && midiOnsets) {
        estimatedBpm = midiBpm || 120;
        let playbackSource = midiOnsets;
        if (estimatedBpm < 100) {
          estimatedBpm *= 2;
          playbackSource = playbackSource.map((o) => ({ ...o, t: o.t / 2 }));
        }
        midiPlaybackOnsets = selectMidiPlaybackOnsets(playbackSource, midiDuration);
        if (!midiPlaybackOnsets || !midiPlaybackOnsets.length) {
          midiPlaybackOnsets = playbackSource;
        }
        // For MIDI gameplay, chart and background playback share the same 3-track source.
        baseOnsets = midiPlaybackOnsets;
        scrollTime = computeScrollTimeFromBpm(estimatedBpm);
        if (midiTimeSig && (["4/4", "3/4", "5/4", "7/8", "6/8", "9/8", "12/8"].includes(midiTimeSig))) {
          timeSig = midiTimeSig;
        }
        if (timeSig === "auto") {
          const est = estimateTimeSignature(baseOnsets, estimatedBpm);
          barBeats = est.beats;
          ui.timeSigText.textContent = est.label;
        } else {
          const parsed = parseTimeSig(timeSig);
          barBeats = parsed.beats;
          ui.timeSigText.textContent = parsed.label;
        }
        const chartNotes = buildChartFromMidi(baseOnsets, estimatedBpm, Number(ui.density.value));
        chart = chartNotes;
        for (const n of chart) n.hit = false;
        ui.bpm.textContent = String(estimatedBpm);
        ui.notes.textContent = String(chart.length);
        ui.play.disabled = chart.length === 0;
        ui.pause.disabled = chart.length === 0;
        const byTime = new Map();
        for (const n of chart) {
          const k = n.t.toFixed(3);
          byTime.set(k, (byTime.get(k) || 0) + 1);
        }
        let chordCount = 0;
        for (const v of byTime.values()) if (v > 1) chordCount += 1;
        ui.hold.textContent = "0";
        ui.chord.textContent = String(chordCount);
        if (chart.length === 0) {
          setStatus(t("status_none"), true);
        } else {
          setStatus(`${t("status_ready", fileName)} (Hold 0, Chord ${chordCount})`);
        }
        render(0);
        return;
      }
      let baseBuffer = audioBuffer;
      const modeBuffers = {};
      try {
        modeBuffers.drum = await filterDrumBand(audioBuffer);
        modeBuffers.guitar = await filterGuitarBand(audioBuffer);
        modeBuffers.piano = await filterPianoBand(audioBuffer);
        modeBuffers.vocal = await filterVocalBand(audioBuffer);
      } catch (err) {
        modeBuffers.drum = audioBuffer;
        modeBuffers.guitar = audioBuffer;
        modeBuffers.piano = audioBuffer;
        modeBuffers.vocal = audioBuffer;
      }

      const sens = enhanceMode ? 1.35 : 1;
      onsetsByMode = {
        drum: analyzeOnsets(modeBuffers.drum, { sensitivity: sens }),
        guitar: analyzeOnsets(modeBuffers.guitar, { sensitivity: sens }),
        piano: analyzeOnsets(modeBuffers.piano, { sensitivity: sens }),
        vocal: analyzeOnsets(modeBuffers.vocal, { sensitivity: sens }),
        mix: analyzeOnsets(audioBuffer, { sensitivity: sens })
      };

      baseOnsets = enhanceMode
        ? mergeOnsetsWeighted(onsetsByMode, { drum: 1.2, bass: 1.1, guitar: 1.0, piano: 0.9, vocal: 0.8, mix: 0.9 })
        : onsetsByMode.mix;
      estimatedBpm = estimateBpmFromOnsets(baseOnsets);
      scrollTime = computeScrollTimeFromBpm(estimatedBpm);
      const keyInfo = estimateKeyFromBuffer(audioBuffer);
      keyLabel = keyInfo.label;
      keyBaseFreq = 440 * Math.pow(2, (keyInfo.root - 9) / 12) * 4;
      ui.keyStat.textContent = keyLabel;
      beatOffset = beatTrack ? estimateBeatPhase(baseOnsets, estimatedBpm) : 0;
      if (timeSig === "auto") {
        const est = estimateTimeSignature(baseOnsets, estimatedBpm);
        barBeats = est.beats;
        ui.timeSigText.textContent = est.label;
      } else {
        const parsed = parseTimeSig(timeSig);
        barBeats = parsed.beats;
        ui.timeSigText.textContent = parsed.label;
      }
      const barSec = (60 / estimatedBpm) * barBeats;

      if (focusMode === "auto") {
        const autoModes = {
          drum: onsetsByMode.drum,
          guitar: onsetsByMode.guitar,
          piano: onsetsByMode.piano,
          vocal: onsetsByMode.vocal
        };
        chart = buildChartAuto(autoModes, estimatedBpm, Number(ui.density.value), beatOffset, beatLock, barSec);
      } else {
        const chosen = onsetsByMode[focusMode] || onsetsByMode.mix;
        chart = buildChartFromOnsets(chosen, estimatedBpm, Number(ui.density.value), beatOffset, beatLock);
      }
      for (const n of chart) n.hit = false;

      ui.bpm.textContent = String(estimatedBpm);
      ui.notes.textContent = String(chart.length);
      ui.hold.textContent = "0";
      ui.chord.textContent = "0";
      const holdCount = chart.filter((n) => n.type === "hold").length;
      const byTime = new Map();
      for (const n of chart) {
        const k = n.t.toFixed(3);
        byTime.set(k, (byTime.get(k) || 0) + 1);
      }
      let chordCount = 0;
      for (const v of byTime.values()) if (v > 1) chordCount += 1;
      ui.hold.textContent = "0";
      ui.chord.textContent = String(chordCount);
      if (chart.length === 0) {
        setStatus(t("status_none"), true);
      } else {
        setStatus(`${t("status_ready", fileName)} (Hold ${holdCount}, Chord ${chordCount})`);
      }
      ui.play.disabled = chart.length === 0;
      ui.pause.disabled = chart.length === 0;
      ui.regen.disabled = chart.length === 0;
      // Keep the debug counts in status when available.
      render(0);
    }

    function regenChart() {
      if (!baseOnsets.length || !onsetsByMode) return;
      stopGame();
      resetScore();
      scrollTime = computeScrollTimeFromBpm(estimatedBpm);
      beatOffset = beatTrack ? estimateBeatPhase(baseOnsets, estimatedBpm) : 0;
      if (timeSig === "auto") {
        const est = estimateTimeSignature(baseOnsets, estimatedBpm);
        barBeats = est.beats;
        ui.timeSigText.textContent = est.label;
      } else {
        const parsed = parseTimeSig(timeSig);
        barBeats = parsed.beats;
        ui.timeSigText.textContent = parsed.label;
      }
      const barSec = (60 / estimatedBpm) * barBeats;
      if (focusMode === "auto") {
        const autoModes = {
          drum: onsetsByMode.drum,
          guitar: onsetsByMode.guitar,
          piano: onsetsByMode.piano,
          vocal: onsetsByMode.vocal
        };
        chart = buildChartAuto(autoModes, estimatedBpm, Number(ui.density.value), beatOffset, beatLock, barSec);
      } else {
        const chosen = onsetsByMode[focusMode] || onsetsByMode.mix;
        chart = buildChartFromOnsets(chosen, estimatedBpm, Number(ui.density.value), beatOffset, beatLock);
      }
      for (const n of chart) n.hit = false;
      ui.notes.textContent = String(chart.length);
      ui.hold.textContent = "0";
      ui.chord.textContent = "0";
      ui.play.disabled = chart.length === 0;
      ui.pause.disabled = chart.length === 0;
      setStatus(t("status_regen", Number(ui.density.value).toFixed(2)), chart.length === 0);
      render(0);
    }

    async function startGame() {
      if (!audioBuffer || !chart.length) return;
      const audioCtx = ensureAudioContext();
      if (audioCtx.state === "suspended") await audioCtx.resume();

      stopGame();
      resetScore();
      for (const n of chart) n.hit = false;

      sourceNode = audioCtx.createBufferSource();
      sourceNode.buffer = audioBuffer;
      sourceNode.connect(audioCtx.destination);
      sourceNode.onended = () => {
        running = false;
        cancelAnimationFrame(rafId);
        setStatus(t("status_end", score));
        render(audioBuffer.duration + 1);
      };

      startTime = audioCtx.currentTime + 0.08;
      sourceNode.start(startTime);
      if (currentSource === "midi" && midiOnsets) {
        scheduleMidiSynth(midiPlaybackOnsets && midiPlaybackOnsets.length ? midiPlaybackOnsets : midiOnsets, estimatedBpm);
      }
      running = true;
      paused = false;
      pauseOffset = 0;
      nextMissIndex = 0;
      setStatus(t("status_playing"));
      loop();
    }

    async function togglePause() {
      if (!audioBuffer || !chart.length) return;
      const audioCtx = ensureAudioContext();
      if (audioCtx.state === "suspended") await audioCtx.resume();
      if (!paused && running) {
        pauseOffset = audioCtx.currentTime - startTime;
        running = false;
        paused = true;
        cancelAnimationFrame(rafId);
        stopMidiSynth();
        if (sourceNode) {
          sourceNode.stop(0);
          sourceNode.disconnect();
          sourceNode = null;
        }
        ui.pause.textContent = t("btn_resume");
        return;
      }
      if (paused) {
        sourceNode = audioCtx.createBufferSource();
        sourceNode.buffer = audioBuffer;
        sourceNode.connect(audioCtx.destination);
        sourceNode.onended = () => {
          running = false;
          paused = false;
          cancelAnimationFrame(rafId);
          setStatus(t("status_end", score));
          render(audioBuffer.duration + 1);
          ui.pause.textContent = t("btn_pause");
        };
        startTime = audioCtx.currentTime - pauseOffset;
        sourceNode.start(0, pauseOffset);
        if (currentSource === "midi" && midiOnsets) {
          scheduleMidiSynth(midiPlaybackOnsets && midiPlaybackOnsets.length ? midiPlaybackOnsets : midiOnsets, estimatedBpm);
        }
        running = true;
        paused = false;
        setStatus(t("status_playing"));
        ui.pause.textContent = t("btn_pause");
        loop();
      }
    }

    ui.file.addEventListener("change", async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      fileName = file.name;
      setStatus("正在解码音频…");
      currentSource = "audio";
      ui.analyze.disabled = true;
      ui.play.disabled = true;
      ui.pause.disabled = true;
      ui.regen.disabled = true;
      stopGame();
      resetScore();
      onsetsByMode = null;
      midiPlaybackOnsets = null;

      try {
        audioBuffer = await loadAudio(file);
        setStatus(t("status_loaded", fileName));
        ui.analyze.disabled = false;
        ui.bpm.textContent = "-";
        ui.notes.textContent = "-";
        ui.keyStat.textContent = "-";
        ui.hold.textContent = "0";
        ui.chord.textContent = "0";
      } catch (err) {
        audioBuffer = null;
        setStatus(`音频加载失败：${err.message || err}`, true);
      }
    });

    ui.midi.addEventListener("change", async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      try {
        const buf = await file.arrayBuffer();
        const parsed = parseMidi(buf);
        midiOnsets = parsed.onsets;
        midiPlaybackOnsets = null;
        midiBpm = parsed.bpm;
        midiTimeSig = parsed.timeSig;
        midiDuration = parsed.duration;
        currentSource = "midi";
        fileName = file.name.replace(/\.(mid|midi)$/i, "");
        audioBuffer = createSilentBuffer(Math.max(2, midiDuration + 1));
        setStatus(t("status_midi_loaded", fileName));
        ui.analyze.disabled = false;
        ui.bpm.textContent = midiBpm ? String(midiBpm) : "-";
        ui.notes.textContent = "-";
        ui.keyStat.textContent = "-";
        ui.hold.textContent = "0";
        ui.chord.textContent = "0";
        ui.midiModeText.textContent = t(`midi_${midiMode}`) || t("midi_auto");
      } catch (err) {
        setStatus(`MIDI 读取失败：${err.message || err}`, true);
      }
    });

    ui.midiMode.addEventListener("change", () => {
      midiMode = ui.midiMode.value;
      ui.midiModeText.textContent = t(`midi_${midiMode}`) || t("midi_auto");
      if (currentSource === "midi" && midiOnsets) {
        doAnalyze();
      }
    });

    ui.density.addEventListener("input", () => {
      ui.densityText.textContent = `${Number(ui.density.value).toFixed(2)}x`;
      ui.difficultyText.textContent = t("custom");
    });

    ui.offset.addEventListener("input", () => {
      offsetSec = Number(ui.offset.value) / 1000;
      ui.offsetText.textContent = `${ui.offset.value} ms`;
    });

    ui.focusMode.addEventListener("change", () => {
      focusMode = ui.focusMode.value;
      applyI18n();
    });

    ui.beatTrack.addEventListener("change", () => {
      beatTrack = ui.beatTrack.checked;
      ui.beatText.textContent = beatTrack ? t("beat_on") : t("beat_off");
    });

    ui.enhanceMode.addEventListener("change", () => {
      enhanceMode = ui.enhanceMode.checked;
      ui.enhanceText.textContent = enhanceMode ? t("enhance_on") : t("enhance_off");
    });

    ui.timeSig.addEventListener("change", () => {
      timeSig = ui.timeSig.value;
      ui.timeSigText.textContent = timeSig === "auto" ? t("time_auto") : timeSig;
    });

    ui.beatLock.addEventListener("input", () => {
      beatLock = Number(ui.beatLock.value);
      ui.beatLockText.textContent = `${Math.round(beatLock * 100)}%`;
    });

    ui.sfxVolume.addEventListener("input", () => {
      sfxVolume = Number(ui.sfxVolume.value);
      ui.sfxText.textContent = `${Math.round(sfxVolume * 100)}%`;
    });

    ui.difficulty.addEventListener("change", () => {
      difficulty = ui.difficulty.value;
      updateDifficulty();
    });

    ui.laneCount.addEventListener("change", () => {
      laneCount = Number(ui.laneCount.value);
      ui.laneText.textContent = `${laneCount} 键`;
      buildKeyMap();
      if (onsetsByMode && baseOnsets.length) {
        regenChart();
      } else {
        render(0);
      }
    });

    const guide = document.getElementById("guide");
    const guideOk = document.getElementById("guideOk");
    const guideHide = document.getElementById("guideHide");
    const mobileToggle = document.getElementById("mobileToggle");
    const leftPanel = document.querySelector(".left");
    const updateMobileToggle = () => {
      const isCollapsed = leftPanel.classList.contains("collapsed");
      mobileToggle.textContent = isCollapsed ? t("mobile_open") : t("mobile_close");
    };
    const hideGuide = () => {
      guide.style.display = "none";
    };
    if (localStorage.getItem("hideGuide") === "1") {
      hideGuide();
    }
    guideOk.addEventListener("click", hideGuide);
    guideHide.addEventListener("click", () => {
      localStorage.setItem("hideGuide", "1");
      hideGuide();
    });
    mobileToggle.addEventListener("click", () => {
      leftPanel.classList.toggle("collapsed");
      updateMobileToggle();
    });

    ui.analyze.addEventListener("click", doAnalyze);
    ui.regen.addEventListener("click", regenChart);
    ui.play.addEventListener("click", startGame);
    ui.pause.addEventListener("click", togglePause);
    ui.sample.addEventListener("click", loadSample);
    ui.record.addEventListener("click", startRecording);
    ui.stopRecord.addEventListener("click", stopRecording);

    // Watchdog: restart the render loop if it stalls while audio keeps playing.
    setInterval(() => {
      if (!running || paused || !ctx) return;
      const now = performance.now();
      if (lastFrameTs && now - lastFrameTs > 600) {
        cancelAnimationFrame(rafId);
        loop();
      }
    }, 500);

    document.addEventListener("visibilitychange", () => {
      if (!document.hidden && running && !paused) {
        cancelAnimationFrame(rafId);
        loop();
      }
    });

    window.addEventListener("keydown", (e) => {
      const lane = keyMap[e.key.toLowerCase()];
      if (lane === undefined) return;
      if (pressedKeys.has(e.key.toLowerCase())) return;
      pressedKeys.add(e.key.toLowerCase());
      ui.keyEls[lane].classList.add("hit");
      setTimeout(() => ui.keyEls[lane].classList.remove("hit"), 80);
      hitLane(lane);
    });

    window.addEventListener("keyup", (e) => {
      const lane = keyMap[e.key.toLowerCase()];
      if (lane === undefined) return;
      pressedKeys.delete(e.key.toLowerCase());
      releaseLane(lane);
    });

    const langToggle = document.getElementById("langToggle");
    langToggle.addEventListener("change", () => {
      lang = langToggle.value;
      applyI18n();
      ui.densityText.textContent = `${Number(ui.density.value).toFixed(2)}x`;
      ui.offsetText.textContent = `${ui.offset.value} ms`;
      ui.sfxText.textContent = `${Math.round(sfxVolume * 100)}%`;
      ui.status.textContent = t("status_idle");
      updateMobileToggle();
    });

    buildKeyMap();
    updateDifficulty();
    ui.sfxText.textContent = `${Math.round(sfxVolume * 100)}%`;
    applyI18n();
    ui.status.textContent = t("status_idle");
    ui.recordTimer.textContent = "60s";
    updateMobileToggle();
    render(0);
  </script>
</body>
</html>
